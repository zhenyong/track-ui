<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">// @tag class
<span id='Tk-Loader'>/**
</span> * This class provides dynamic loading support for JavaScript classes. Application code
 * does not typically need to call `Tk.Loader` except perhaps to configure path mappings
 * when not using [Sencha Cmd](http://www.sencha.com/products/sencha-cmd/).
 *
 *      Tk.Loader.setPath(&#39;MyApp&#39;, &#39;app&#39;);
 *
 * When using Sencha Cmd, this is handled by the &quot;bootstrap&quot; provided by the application
 * build script and such configuration is not necessary.
 *
 * # Typical Usage
 *
 * The `Tk.Loader` is most often used behind the scenes to satisfy class references in
 * class declarations. Like so:
 *
 *      Tk.define(&#39;MyApp.view.Main&#39;, {
 *          extend: &#39;Tk.panel.Panel&#39;,
 *
 *          mixins: [
 *              &#39;MyApp.util.Mixin&#39;
 *          ],
 *
 *          requires: [
 *              &#39;Tk.grid.Panel&#39;
 *          ],
 *
 *          uses: [
 *              &#39;MyApp.util.Stuff&#39;
 *          ]
 *      });
 *
 * In all of these cases, `Tk.Loader` is used internally to resolve these class names
 * and ensure that the necessary class files are loaded.
 *
 * During development, these files are loaded individually for optimal debugging. For a
 * production use, [Sencha Cmd](http://www.sencha.com/products/sencha-cmd/) will replace
 * all of these strings with the actual resolved class references because it ensures that
 * the classes are all contained in the build in the correct order. In development, these
 * files will not be loaded until the `MyApp.view.Main` class indicates they are needed
 * as shown above.
 *
 * # Loading Classes
 *
 * You can also use `Tk.Loader` directly to load classes or files. The simplest form of
 * use is `{@link Tk#require}`.
 *
 * For example:
 *
 *      Tk.require(&#39;MyApp.view.Main&#39;, function () {
 *          // On callback, the MyApp.view.Main class is now loaded
 *
 *          var view = new MyApp.view.Main();
 *      });
 *
 * You can alternatively require classes by alias or wildcard.
 *
 *     Tk.require(&#39;widget.window&#39;);
 *
 *     Tk.require([&#39;widget.window&#39;, &#39;layout.border&#39;, &#39;Tk.data.Connection&#39;]);
 *
 *     Tk.require([&#39;widget.*&#39;, &#39;layout.*&#39;, &#39;Tk.data.*&#39;]);
 *
 * The callback function is optional.
 *
 * **Note** Using `Tk.require` at global scope will cause `{@link Tk#onReady}` and
 * `{@link Tk.app.Application#launch}` methods to be deferred until the required classes
 * are loaded. It is these cases where the callback function is most often unnecessary.
 *
 * ## Using Excludes
 *
 * Alternatively, you can exclude what you don&#39;t need:
 *
 *     // Include everything except Tk.tree.*
 *     Tk.exclude(&#39;Tk.tree.*&#39;).require(&#39;*&#39;);
 *
 *     // Include all widgets except widget.checkbox* (this will exclude
 *     // widget.checkbox, widget.checkboxfield, widget.checkboxgroup, etc.)
 *     Tk.exclude(&#39;widget.checkbox*&#39;).require(&#39;widget.*&#39;);
 *
 * # Dynamic Instantiation
 *
 * Another feature enabled by `Tk.Loader` is instantiation using class names or aliases.
 *
 * For example:
 *
 *      var win = Tk.create({
 *          xtype: &#39;window&#39;,
 *
 *          // or
 *          // xclass: &#39;Tk.window.Window&#39;
 *
 *          title: &#39;Hello&#39;
 *      });
 *
 * This form of creation can be useful if the type to create (`window` in the above) is
 * not known statically. Internally, `{@link Tk#create}` may need to *synchronously*
 * load the desired class and its requirements. Doing this will generate a warning in
 * the console:
 * 
 *      [Tk.Loader] Synchronously loading &#39;Tk.window.Window&#39;...
 *
 * If you see these in your debug console, you should add the indicated class(es) to the
 * appropriate `requires` array (as above) or make an `{@link Tk#require}` call.
 * 
 * 
 * **Note** Using `{@link Tk#create}` has some performance overhead and is best reserved
 * for cases where the target class is not known until run-time.
 * 
 * @class Tk.Loader
 * @singleton
 */
Tk.Loader = (new function() {  // jshint ignore:line
// @define Tk.Loader
// @require Tk.Base
// @require Tk.Class
// @require Tk.ClassManager
// @require Tk.Function
// @require Tk.Array
// @require Tk.env.Ready

    var Loader = this,
        Manager = Tk.ClassManager, // this is an instance of Tk.Inventory
        Boot = Tk.Boot,
        Class = Tk.Class,
        Ready = Tk.env.Ready,
        alias = Tk.Function.alias,
        dependencyProperties = [&#39;extend&#39;, &#39;mixins&#39;, &#39;requires&#39;],
        isInHistory = {},
        history = [],
        readyListeners = [],
        usedClasses = [],
        _requiresMap = {},
        _missingQueue = {},
        _config = {
<span id='Tk-Loader-cfg-enabled'>            /**
</span>             * @cfg {Boolean} [enabled=true]
             * Whether or not to enable the dynamic dependency loading feature.
             */
            enabled: true,

<span id='Tk-Loader-cfg-scriptChainDelay'>            /**
</span>             * @cfg {Boolean} [scriptChainDelay=false]
             * millisecond delay between asynchronous script injection (prevents stack
             * overflow on some user agents) &#39;false&#39; disables delay but potentially
             * increases stack load.
             */
            scriptChainDelay: false,

<span id='Tk-Loader-cfg-disableCaching'>            /**
</span>             * @cfg {Boolean} [disableCaching=true]
             * Appends current timestamp to script files to prevent caching.
             */
            disableCaching: true,

<span id='Tk-Loader-cfg-disableCachingParam'>            /**
</span>             * @cfg {String} [disableCachingParam=&quot;_dc&quot;]
             * The get parameter name for the cache buster&#39;s timestamp.
             */
            disableCachingParam: &#39;_dc&#39;,

<span id='Tk-Loader-cfg-paths'>            /**
</span>             * @cfg {Object} paths
             * The mapping from namespaces to file paths
             *
             *     {
             *         &#39;Tk&#39;: &#39;.&#39;, // This is set by default, Tk.layout.container.Container will be
             *                     // loaded from ./layout/Container.js
             *
             *         &#39;My&#39;: &#39;./src/my_own_folder&#39; // My.layout.Container will be loaded from
             *                                     // ./src/my_own_folder/layout/Container.js
             *     }
             *
             * Note that all relative paths are relative to the current HTML document.
             * If not being specified, for example, `Other.awesome.Class` will simply be
             * loaded from `&quot;./Other/awesome/Class.js&quot;`.
             */
            paths: Manager.paths,

<span id='Tk-Loader-cfg-preserveScripts'>            /**
</span>             * @cfg {Boolean} preserveScripts
             * `false` to remove asynchronously loaded scripts, `true` to retain script
             * element for browser debugger compatibility and improved load performance.
             */
            preserveScripts: true,

<span id='Tk-Loader-cfg-scriptCharset'>            /**
</span>             * @cfg {String} scriptCharset
             * Optional charset to specify encoding of dynamic script content.
             */
            scriptCharset: undefined
        },
        // These configs are delegated to Tk.Script and may need different names:
        delegatedConfigs = {
            disableCaching: true,
            disableCachingParam: true,
            preserveScripts: true,
            scriptChainDelay: &#39;loadDelay&#39;
        };

    Tk.apply(Loader, {
<span id='Tk-Loader-property-isInHistory'>        /**
</span>         * @private
         */
        isInHistory: isInHistory,

<span id='Tk-Loader-property-isLoading'>        /**
</span>         * Flag indicating whether there are still files being loaded
         * @private
         */
        isLoading: false,

<span id='Tk-Loader-property-history'>        /**
</span>         * An array of class names to keep track of the dependency loading order.
         * This is not guaranteed to be the same everytime due to the asynchronous
         * nature of the Loader.
         *
         * @property {Array} history
         */
        history: history,

<span id='Tk-Loader-property-config'>        /**
</span>         * Configuration
         * @private
         */
        config: _config,

<span id='Tk-Loader-property-readyListeners'>        /**
</span>         * Maintain the list of listeners to execute when all required scripts are fully loaded
         * @private
         */
        readyListeners: readyListeners,

<span id='Tk-Loader-property-optionalRequires'>        /**
</span>         * Contains classes referenced in `uses` properties.
         * @private
         */
        optionalRequires: usedClasses,

<span id='Tk-Loader-property-requiresMap'>        /**
</span>         * Map of fully qualified class names to an array of dependent classes.
         * @private
         */
        requiresMap: _requiresMap,

<span id='Tk-Loader-property-hasFileLoadError'>        /** @private */
</span>        hasFileLoadError: false,

<span id='Tk-Loader-property-scriptsLoading'>        /**
</span>         * The number of scripts loading via loadScript.
         * @private
         */
        scriptsLoading: 0,

        //&lt;debug&gt;
<span id='Tk-Loader-property-classesLoading'>        /**
</span>         * @private
         */
        classesLoading: [],
        //&lt;/debug&gt;

<span id='Tk-Loader-property-syncModeEnabled'>        /**
</span>         * @private
         */
        syncModeEnabled: false,

        
<span id='Tk-Loader-property-missingQueue'>        /**
</span>         * @private
         */
        missingQueue: _missingQueue,
        
        init: function () {
            // initalize the default path of the framework
            var scripts = document.getElementsByTagName(&#39;script&#39;),
                src = scripts[scripts.length - 1].src,
                path = src.substring(0, src.lastIndexOf(&#39;/&#39;) + 1),
                meta = Tk._classPathMetadata,
                microloader = Tk.Microloader,
                manifest = Tk.manifest,
                loadOrder, baseUrl, loadlen, l, loadItem;

            //&lt;debug&gt;
            if (src.indexOf(&quot;packages/core/src/&quot;) !== -1) {
                path = path + &quot;../../&quot;;
            } else if (src.indexOf(&quot;/core/src/class/&quot;) !== -1) {
                path = path + &quot;../../../&quot;;
            }
            //&lt;/debug&gt;

            
            if(!Manager.getPath(&quot;Tk&quot;)) {
                Manager.setPath(&#39;Tk&#39;, path + &#39;src&#39;);
            }

            // Pull in Cmd generated metadata if available.
            if (meta) {
                Tk._classPathMetadata = null;
                Loader.addClassPathMappings(meta);
            }
            
            if(manifest) {
                loadOrder = manifest.loadOrder;
                // if the manifest paths were calculated as relative to the 
                // bootstrap file, then we need to prepend Boot.baseUrl to the
                // paths before processing
                baseUrl = Tk.Boot.baseUrl;
                if(loadOrder &amp;&amp; manifest.bootRelative) {
                    for(loadlen = loadOrder.length, l = 0; l &lt; loadlen; l++) {
                        loadItem = loadOrder[l];
                        loadItem.path = baseUrl + loadItem.path;
                    }                    
                }
            }
            
            if(microloader) {
                Ready.block();
                microloader.onMicroloaderReady(function(){
                    Ready.unblock();
                });
            }
        },

<span id='Tk-Loader-method-setConfig'>        /**
</span>         * Set the configuration for the loader. This should be called right after ext-(debug).js
         * is included in the page, and before Tk.onReady. i.e:
         *
         *     &lt;script type=&quot;text/javascript&quot; src=&quot;ext-core-debug.js&quot;&gt;&lt;/script&gt;
         *     &lt;script type=&quot;text/javascript&quot;&gt;
         *         Tk.Loader.setConfig({
         *           enabled: true,
         *           paths: {
         *               &#39;My&#39;: &#39;my_own_path&#39;
         *           }
         *         });
         *     &lt;/script&gt;
         *     &lt;script type=&quot;text/javascript&quot;&gt;
         *         Tk.require(...);
         *
         *         Tk.onReady(function() {
         *           // application code here
         *         });
         *     &lt;/script&gt;
         *
         * Refer to config options of {@link Tk.Loader} for the list of possible properties
         *
         * @param {Object} config The config object to override the default values
         * @return {Tk.Loader} this
         */
        setConfig: Tk.Function.flexSetter(function (name, value) {
            if (name === &#39;paths&#39;) {
                Loader.setPath(value);
            } else {
                _config[name] = value;

                var delegated = delegatedConfigs[name];
                if (delegated) {
                    Boot.setConfig((delegated === true) ? name : delegated, value);
                }
            }

            return Loader;
        }),

<span id='Tk-Loader-method-getConfig'>        /**
</span>         * Get the config value corresponding to the specified name. If no name is given, will return the config object
         * @param {String} name The config property name
         * @return {Object}
         */
        getConfig: function(name) {
            return name ? _config[name] : _config;
        },

<span id='Tk-Loader-method-setPath'>        /**
</span>         * Sets the path of a namespace.
         * For Example:
         *
         *     Tk.Loader.setPath(&#39;Tk&#39;, &#39;.&#39;);
         *
         * @param {String/Object} name See {@link Tk.Function#flexSetter flexSetter}
         * @param {String} [path] See {@link Tk.Function#flexSetter flexSetter}
         * @return {Tk.Loader} this
         * @method
         */
        setPath: function () {
            // Paths are an Tk.Inventory thing and ClassManager is an instance of that:
            Manager.setPath.apply(Manager, arguments);
            return Loader;
        },

<span id='Tk-Loader-method-addClassPathMappings'>        /**
</span>         * Sets a batch of path entries
         *
         * @param {Object } paths a set of className: path mappings
         * @return {Tk.Loader} this
         */
        addClassPathMappings: function(paths) {
            // Paths are an Tk.Inventory thing and ClassManager is an instance of that:
            Manager.setPath(paths);
            return Loader;
        },

<span id='Tk-Loader-method-addBaseUrlClassPathMappings'>        /**
</span>         * fixes up loader path configs by prepending Tk.Boot#baseUrl to the beginning
         * of the path, then delegates to Tk.Loader#addClassPathMappings
         * @param pathConfig
         */

        addBaseUrlClassPathMappings: function(pathConfig) {
            for(var name in pathConfig) {
                pathConfig[name] = Boot.baseUrl + pathConfig[name];
            }
            Tk.Loader.addClassPathMappings(pathConfig);
        },


<span id='Tk-Loader-method-getPath'>        /**
</span>         * Translates a className to a file path by adding the
         * the proper prefix and converting the .&#39;s to /&#39;s. For example:
         *
         *     Tk.Loader.setPath(&#39;My&#39;, &#39;/path/to/My&#39;);
         *
         *     alert(Tk.Loader.getPath(&#39;My.awesome.Class&#39;)); // alerts &#39;/path/to/My/awesome/Class.js&#39;
         *
         * Note that the deeper namespace levels, if explicitly set, are always resolved first. For example:
         *
         *     Tk.Loader.setPath({
         *         &#39;My&#39;: &#39;/path/to/lib&#39;,
         *         &#39;My.awesome&#39;: &#39;/other/path/for/awesome/stuff&#39;,
         *         &#39;My.awesome.more&#39;: &#39;/more/awesome/path&#39;
         *     });
         *
         *     alert(Tk.Loader.getPath(&#39;My.awesome.Class&#39;)); // alerts &#39;/other/path/for/awesome/stuff/Class.js&#39;
         *
         *     alert(Tk.Loader.getPath(&#39;My.awesome.more.Class&#39;)); // alerts &#39;/more/awesome/path/Class.js&#39;
         *
         *     alert(Tk.Loader.getPath(&#39;My.cool.Class&#39;)); // alerts &#39;/path/to/lib/cool/Class.js&#39;
         *
         *     alert(Tk.Loader.getPath(&#39;Unknown.strange.Stuff&#39;)); // alerts &#39;Unknown/strange/Stuff.js&#39;
         *
         * @param {String} className
         * @return {String} path
         */
        getPath: function(className) {
            // Paths are an Tk.Inventory thing and ClassManager is an instance of that:
            return Manager.getPath(className);
        },

        require: function (expressions, fn, scope, excludes) {
            if (excludes) {
                return Loader.exclude(excludes).require(expressions, fn, scope);
            }

            var classNames = Manager.getNamesByExpression(expressions);

            return Loader.load(classNames, fn, scope);
        },

        syncRequire: function () {
            var wasEnabled = Loader.syncModeEnabled;

            Loader.syncModeEnabled = true;

            var ret = Loader.require.apply(Loader, arguments);

            Loader.syncModeEnabled = wasEnabled;

            return ret;
        },

        exclude: function (excludes) {
            var selector = Manager.select({
                    require: function (classNames, fn, scope) {
                        return Loader.load(classNames, fn, scope);
                    },

                    syncRequire: function (classNames, fn, scope) {
                        var wasEnabled = Loader.syncModeEnabled;

                        Loader.syncModeEnabled = true;

                        var ret = Loader.load(classNames, fn, scope);

                        Loader.syncModeEnabled = wasEnabled;

                        return ret;
                    }
                });

            selector.exclude(excludes);
            return selector;
        },

        load: function (classNames, callback, scope) {
            if (callback) {
                if (callback.length) {
                    // If callback expects arguments, shim it with a function that will map
                    // the requires class(es) from the names we are given.
                    callback = Loader.makeLoadCallback(classNames, callback);
                }
                callback = callback.bind(scope || Tk.global);
            }

            var missingClassNames = [],
                numClasses = classNames.length,
                className, i, numMissing, urls = [],
                state = Manager.classState;
            
            for (i = 0; i &lt; numClasses; ++i) {
                className = Manager.resolveName(classNames[i]);
                if (!Manager.isCreated(className)) {
                    missingClassNames.push(className);
                    _missingQueue[className] = Loader.getPath(className);
                    if(!state[className]) {
                        urls.push(_missingQueue[className]);
                    }
                }
            }

            // If the dynamic dependency feature is not being used, throw an error
            // if the dependencies are not defined
            numMissing = missingClassNames.length;
            if (numMissing) {
                Loader.missingCount += numMissing;
                //&lt;debug&gt;
                Tk.Array.push(Loader.classesLoading, missingClassNames);
                //&lt;/debug&gt;

                Manager.onCreated(function () {
                    //&lt;debug&gt;
                    Tk.Array.remove(Loader.classesLoading, missingClassNames);
                    Tk.each(missingClassNames, function(name){
                        Tk.Array.remove(Loader.classesLoading, name);
                    });
                    //&lt;/debug&gt;
                    if (callback) {
                        Tk.callback(callback, scope, arguments);
                    }
                    Loader.checkReady();
                }, Loader, missingClassNames);

                if (!_config.enabled) {
                    Tk.raise(&quot;Tk.Loader is not enabled, so dependencies cannot be resolved dynamically. &quot; +
                             &quot;Missing required class&quot; + ((missingClassNames.length &gt; 1) ? &quot;es&quot; : &quot;&quot;) + 
                             &quot;: &quot; + missingClassNames.join(&#39;, &#39;));
                }

                if(urls.length) {
                    Loader.loadScripts({
                        url: urls,
                        // scope: this options object so we can pass these along:
                        _classNames: missingClassNames
                    });
                } else {
                    // need to call checkReady here, as the _missingCoun
                    // may have transitioned from 0 to &gt; 0, meaning we
                    // need to block ready
                    Loader.checkReady();
                }
            } else {
                if (callback) {
                    callback.call(scope);
                }
                // need to call checkReady here, as the _missingCoun
                // may have transitioned from 0 to &gt; 0, meaning we
                // need to block ready
                Loader.checkReady();
            }
            
            if (Loader.syncModeEnabled) {
                // Class may have been just loaded or was already loaded
                if (numClasses === 1) {
                    return Manager.get(classNames[0]);
                }
            }

            return Loader;
        },

        makeLoadCallback: function (classNames, callback) {
            return function () {
                var classes = [],
                    i = classNames.length;

                while (i-- &gt; 0) {
                    classes[i] = Manager.get(classNames[i]);
                }

                return callback.apply(this, classes);
            };
        },
        
        onLoadFailure: function () {
            var options = this,
                onError = options.onError;

            Loader.hasFileLoadError = true;
            --Loader.scriptsLoading;

            if (onError) {
                //TODO: need an adapter to convert to v4 onError signatures
                onError.call(options.userScope, options);
            }
            //&lt;debug&gt;
            else {
                Tk.log.error(&quot;[Tk.Loader] Some requested files failed to load.&quot;);
            }
            //&lt;/debug&gt;

            Loader.checkReady();
        },

        onLoadSuccess: function () {
            var options = this,
                onLoad = options.onLoad;

            --Loader.scriptsLoading;
            if (onLoad) {
                //TODO: need an adapter to convert to v4 onLoad signatures
                onLoad.call(options.userScope, options);
                // onLoad can cause more loads to start, so it must run first
            }

            Loader.checkReady();
        },

// TODO: this timing of this needs to be deferred until all classes have had a chance to be created
        //&lt;debug&gt;
        reportMissingClasses: function () {
            if (!Loader.syncModeEnabled &amp;&amp; !Loader.scriptsLoading &amp;&amp; Loader.isLoading &amp;&amp;
                    !Loader.hasFileLoadError) {
                var missingClasses = [],
                    missingPaths = [];

                for (var missingClassName in _missingQueue) {
                    missingClasses.push(missingClassName);
                    missingPaths.push(_missingQueue[missingClassName]);
                }

                if (missingClasses.length) {
                    throw new Error(&quot;The following classes are not declared even if their files have been &quot; +
                        &quot;loaded: &#39;&quot; + missingClasses.join(&quot;&#39;, &#39;&quot;) + &quot;&#39;. Please check the source code of their &quot; +
                        &quot;corresponding files for possible typos: &#39;&quot; + missingPaths.join(&quot;&#39;, &#39;&quot;));
                }
            }
        },
        //&lt;/debug&gt;

<span id='Tk-Loader-method-onReady'>        /**
</span>         * Add a new listener to be executed when all required scripts are fully loaded
         *
         * @param {Function} fn The function callback to be executed
         * @param {Object} scope The execution scope (`this`) of the callback function.
         * @param {Boolean} [withDomReady=true] Pass `false` to not also wait for document
         * dom ready.
         * @param {Object} [options] Additional callback options.
         * @param {Number} [options.delay=0] A number of milliseconds to delay.
         * @param {Number} [options.priority=0] Relative priority of this callback. Negative
         * numbers are reserved.
         */
        onReady: function(fn, scope, withDomReady, options) {
            if (withDomReady) {
                Ready.on(fn, scope, options);
            } else {
                var listener = Ready.makeListener(fn, scope, options);

                if (Loader.isLoading) {
                    readyListeners.push(listener);
                } else {
                    Ready.invoke(listener);
                }
            }
        },

<span id='Tk-Loader-method-addUsedClasses'>        /**
</span>         * @private
         * Ensure that any classes referenced in the `uses` property are loaded.
         */
        addUsedClasses: function (classes) {
            var cls, i, ln;

            if (classes) {
                classes = (typeof classes === &#39;string&#39;) ? [classes] : classes;
                for (i = 0, ln = classes.length; i &lt; ln; i++) {
                    cls = classes[i];
                    if (typeof cls === &#39;string&#39; &amp;&amp; !Tk.Array.contains(usedClasses, cls)) {
                        usedClasses.push(cls);
                    }
                }
            }

            return Loader;
        },

<span id='Tk-Loader-method-triggerReady'>        /**
</span>         * @private
         */
        triggerReady: function() {
            var listener,
                refClasses = usedClasses;

            if (Loader.isLoading &amp;&amp; refClasses.length) {
                // Empty the array to eliminate potential recursive loop issue
                usedClasses = [];

                // this may immediately call us back if all &#39;uses&#39; classes
                // have been loaded
                Loader.require(refClasses);
            } else {
                // Must clear this before calling callbacks. This will cause any new loads
                // to call Ready.block() again. See below for more on this.
                Loader.isLoading = false;

                // These listeners are just those attached directly to Loader to wait for
                // class loading only.
                readyListeners.sort(Ready.sortFn);

                // this method can be called with Loader.isLoading either true or false
                // (can be called with false when all &#39;uses&#39; classes are already loaded)
                // this may bypass the above if condition
                while (readyListeners.length &amp;&amp; !Loader.isLoading) {
                    // we may re-enter triggerReady so we cannot necessarily iterate the
                    // readyListeners array
                    listener = readyListeners.pop();
                    Ready.invoke(listener);
                }

                // If the DOM is also ready, this will fire the normal onReady listeners.
                // An astute observer would note that we may now be back to isLoading and
                // so ask &quot;Why you call unblock?&quot;. The reason is that we must match the
                // calls to block and since we transitioned from isLoading to !isLoading
                // here we must call unblock. If we have transitioned back to isLoading in
                // the above loop it will have called block again so the counter will be
                // increased and this call will not reduce the block count to 0. This is
                // done by loadScripts.
                Ready.unblock();
            }
        },

<span id='Tk-Loader-method-historyPush'>        /**
</span>         * @private
         * @param {String} className
         */
        historyPush: function(className) {
            if (className &amp;&amp; !isInHistory[className] &amp;&amp; !Manager.overrideMap[className]) {
                isInHistory[className] = true;
                history.push(className);
            }
            return Loader;
        },

<span id='Tk-Loader-method-loadScripts'>        /**
</span>         * This is an internal method that delegate content loading to the 
         * bootstrap layer.
         * @private
         * @param params
         */
        loadScripts: function(params) {
            var manifest = Tk.manifest,
                loadOrder = manifest &amp;&amp; manifest.loadOrder,
                loadOrderMap = manifest &amp;&amp; manifest.loadOrderMap,
                options;
            
            ++Loader.scriptsLoading;
            
            // if the load order map hasn&#39;t been created, create it now 
            // and cache on the manifest
            if (loadOrder &amp;&amp; !loadOrderMap) {
                manifest.loadOrderMap = loadOrderMap = Boot.createLoadOrderMap(loadOrder);
            }

            // verify the loading state, as this may have transitioned us from
            // not loading to loading
            Loader.checkReady();

            options = Tk.apply({
                loadOrder: loadOrder,
                loadOrderMap: loadOrderMap,
                charset: _config.scriptCharset,
                success: Loader.onLoadSuccess,
                failure: Loader.onLoadFailure,
                sync: Loader.syncModeEnabled,
                _classNames: []
            }, params);

            options.userScope = options.scope;
            options.scope = options;

            Boot.load(options);
        },

<span id='Tk-Loader-method-loadScriptsSync'>        /**
</span>         * This method is provide for use by the bootstrap layer.
         * @private
         * @param {String[]} urls
         */
        loadScriptsSync: function(urls) {
            var syncwas = Loader.syncModeEnabled;
            Loader.syncModeEnabled = true;
            Loader.loadScripts({url: urls});
            Loader.syncModeEnabled = syncwas;
        },

<span id='Tk-Loader-method-loadScriptsSyncBasePrefix'>        /**
</span>         * This method is provide for use by the bootstrap layer.
         * @private
         * @param {String[]} urls
         */
        loadScriptsSyncBasePrefix: function(urls) {
            var syncwas = Loader.syncModeEnabled;
            Loader.syncModeEnabled = true;
            Loader.loadScripts({url: urls, prependBaseUrl: true});
            Loader.syncModeEnabled = syncwas;
        },
        
<span id='Tk-Loader-method-loadScript'>        /**
</span>         * Loads the specified script URL and calls the supplied callbacks. If this method
         * is called before {@link Tk#isReady}, the script&#39;s load will delay the transition
         * to ready. This can be used to load arbitrary scripts that may contain further
         * {@link Tk#require Tk.require} calls.
         *
         * @param {Object/String/String[]} options The options object or simply the URL(s) to load.
         * @param {String} options.url The URL from which to load the script.
         * @param {Function} [options.onLoad] The callback to call on successful load.
         * @param {Function} [options.onError] The callback to call on failure to load.
         * @param {Object} [options.scope] The scope (`this`) for the supplied callbacks.
         */
        loadScript: function(options) {
            var isString = typeof options === &#39;string&#39;,
                isArray = options instanceof Array,
                isObject = !isArray &amp;&amp; !isString,
                url = isObject ? options.url : options,
                onError = isObject &amp;&amp; options.onError,
                onLoad = isObject &amp;&amp; options.onLoad,
                scope = isObject &amp;&amp; options.scope,
                request = {
                    url: url,
                    scope: scope,
                    onLoad: onLoad,
                    onError: onError,
                    _classNames: []
                };

            Loader.loadScripts(request);
        },

<span id='Tk-Loader-method-flushMissingQueue'>        /**
</span>         * @private
         */
        flushMissingQueue: function() {
            var name, val, missingwas = 0, missing = 0;
            
            for(name in _missingQueue) {
                missingwas++;
                val = _missingQueue[name];
                if(Manager.isCreated(name)) {
                    delete _missingQueue[name];
                } else if (Manager.existCache[name] === 2) {
                    delete _missingQueue[name];
                } else {
                    ++missing;
                }
            }
            this.missingCount = missing;
        },

<span id='Tk-Loader-method-checkReady'>        /**
</span>         * @private
         */
        checkReady: function() {
            var wasLoading = Loader.isLoading,
                isLoading;

            Loader.flushMissingQueue();
            isLoading = Loader.missingCount + Loader.scriptsLoading;
            
            if (isLoading &amp;&amp; !wasLoading) {
                Ready.block();
                Loader.isLoading = !!isLoading;
            } else if (!isLoading &amp;&amp; wasLoading) {
                Loader.triggerReady();
            }

            //&lt;debug&gt;
            if (!Loader.scriptsLoading &amp;&amp; Loader.missingCount) {
                // Things look bad, but since load requests may come later, defer this
                // for a bit then check if things are still stuck.
                Tk.defer(function () {
                    if (!Loader.scriptsLoading &amp;&amp; Loader.missingCount) {
                        Tk.log.error(&#39;[Loader] The following classes failed to load:&#39;);
                        for (var name in Loader.missingQueue) {
                            Tk.log.error(&#39;[Loader] &#39; + name + &#39; from &#39; +
                                Loader.missingQueue[name]);
                        }
                    }
                }, 1000);
            }
            //&lt;/debug&gt;
        }
    });

<span id='Tk-method-require'>    /**
</span>     * Loads all classes by the given names and all their direct dependencies; optionally
     * executes the given callback function when finishes, within the optional scope.
     *
     * @param {String/String[]} expressions The class, classes or wildcards to load.
     * @param {Function} [fn] The callback function.
     * @param {Object} [scope] The execution scope (`this`) of the callback function.
     * @member Tk
     * @method require
     */
    Tk.require = alias(Loader, &#39;require&#39;);

<span id='Tk-method-syncRequire'>    /**
</span>     * Synchronously loads all classes by the given names and all their direct dependencies; optionally
     * executes the given callback function when finishes, within the optional scope.
     *
     * @param {String/String[]} expressions The class, classes or wildcards to load.
     * @param {Function} [fn] The callback function.
     * @param {Object} [scope] The execution scope (`this`) of the callback function.
     * @member Tk
     * @method syncRequire
     */
    Tk.syncRequire = alias(Loader, &#39;syncRequire&#39;);

<span id='Tk-method-exclude'>    /**
</span>     * Explicitly exclude files from being loaded. Useful when used in conjunction with a
     * broad include expression. Can be chained with more `require` and `exclude` methods,
     * for example:
     *
     *     Tk.exclude(&#39;Tk.data.*&#39;).require(&#39;*&#39;);
     *
     *     Tk.exclude(&#39;widget.button*&#39;).require(&#39;widget.*&#39;);
     *
     * @param {String/String[]} excludes
     * @return {Object} Contains `exclude`, `require` and `syncRequire` methods for chaining.
     * @member Tk
     * @method exclude
     */
    Tk.exclude = alias(Loader, &#39;exclude&#39;);

//&lt;feature classSystem.loader&gt;
<span id='Tk-Class-cfg-requires'>    /**
</span>     * @cfg {String[]} requires
     * @member Tk.Class
     * List of classes that have to be loaded before instantiating this class.
     * For example:
     *
     *     Tk.define(&#39;Mother&#39;, {
     *         requires: [&#39;Child&#39;],
     *         giveBirth: function() {
     *             // we can be sure that child class is available.
     *             return new Child();
     *         }
     *     });
     */
    Class.registerPreprocessor(&#39;loader&#39;, function(cls, data, hooks, continueFn) {
        //&lt;debug&gt;
        Tk.classSystemMonitor &amp;&amp; Tk.classSystemMonitor(cls, &#39;Tk.Loader#loaderPreprocessor&#39;, arguments); // jshint ignore:line
        //&lt;/debug&gt;
        
        var me = this,
            dependencies = [],
            dependency,
            className = Manager.getName(cls),
            i, j, ln, subLn, value, propertyName, propertyValue,
            requiredMap;

        /*
        Loop through the dependencyProperties, look for string class names and push
        them into a stack, regardless of whether the property&#39;s value is a string, array or object. For example:
        {
              extend: &#39;Tk.MyClass&#39;,
              requires: [&#39;Tk.some.OtherClass&#39;],
              mixins: {
                  thing: &#39;Foo.bar.Thing&#39;;
              }
        }
        which will later be transformed into:
        {
              extend: Tk.MyClass,
              requires: [Tk.some.OtherClass],
              mixins: {
                  thing: Foo.bar.Thing;
              }
        }
        */

        for (i = 0,ln = dependencyProperties.length; i &lt; ln; i++) {
            propertyName = dependencyProperties[i];

            if (data.hasOwnProperty(propertyName)) {
                propertyValue = data[propertyName];

                if (typeof propertyValue === &#39;string&#39;) {
                    dependencies.push(propertyValue);
                }
                else if (propertyValue instanceof Array) {
                    for (j = 0, subLn = propertyValue.length; j &lt; subLn; j++) {
                        value = propertyValue[j];

                        if (typeof value === &#39;string&#39;) {
                            dependencies.push(value);
                        }
                    }
                }
                else if (typeof propertyValue !== &#39;function&#39;) {
                    for (j in propertyValue) {
                        if (propertyValue.hasOwnProperty(j)) {
                            value = propertyValue[j];

                            if (typeof value === &#39;string&#39;) {
                                dependencies.push(value);
                            }
                        }
                    }
                }
            }
        }

        if (dependencies.length === 0) {
            return;
        }
        if (className) {
            _requiresMap[className] = dependencies;
        }

        //&lt;debug&gt;
        var deadlockPath = [],
            detectDeadlock;

        /*
        Automatically detect deadlocks before-hand,
        will throw an error with detailed path for ease of debugging. Examples of deadlock cases:

        - A extends B, then B extends A
        - A requires B, B requires C, then C requires A

        The detectDeadlock function will recursively transverse till the leaf, hence it can detect deadlocks
        no matter how deep the path is.
        */

        if (className) {
            requiredMap = Loader.requiredByMap || (Loader.requiredByMap = {});

            for (i = 0,ln = dependencies.length; i &lt; ln; i++) {
                dependency = dependencies[i];
                (requiredMap[dependency] || (requiredMap[dependency] = [])).push(className);
            }

            detectDeadlock = function(cls) {
                deadlockPath.push(cls);

                if (_requiresMap[cls]) {
                    if (Tk.Array.contains(_requiresMap[cls], className)) {
                        Tk.raise(&quot;Circular requirement detected! &#39;&quot; + className +
                                &quot;&#39; and &#39;&quot; + deadlockPath[1] + &quot;&#39; mutually require each other. Path: &quot; +
                                deadlockPath.join(&#39; -&gt; &#39;) + &quot; -&gt; &quot; + deadlockPath[0]);
                    }

                    for (i = 0,ln = _requiresMap[cls].length; i &lt; ln; i++) {
                        detectDeadlock(_requiresMap[cls][i]);
                    }
                }
            };

            detectDeadlock(className);
        }

        //&lt;/debug&gt;

        (className ? Loader.exclude(className) : Loader).require(dependencies, function() {
            for (i = 0,ln = dependencyProperties.length; i &lt; ln; i++) {
                propertyName = dependencyProperties[i];

                if (data.hasOwnProperty(propertyName)) {
                    propertyValue = data[propertyName];

                    if (typeof propertyValue === &#39;string&#39;) {
                        data[propertyName] = Manager.get(propertyValue);
                    }
                    else if (propertyValue instanceof Array) {
                        for (j = 0, subLn = propertyValue.length; j &lt; subLn; j++) {
                            value = propertyValue[j];

                            if (typeof value === &#39;string&#39;) {
                                data[propertyName][j] = Manager.get(value);
                            }
                        }
                    }
                    else if (typeof propertyValue !== &#39;function&#39;) {
                        for (var k in propertyValue) {
                            if (propertyValue.hasOwnProperty(k)) {
                                value = propertyValue[k];

                                if (typeof value === &#39;string&#39;) {
                                    data[propertyName][k] = Manager.get(value);
                                }
                            }
                        }
                    }
                }
            }

            continueFn.call(me, cls, data, hooks);
        });

        return false;
    }, true, &#39;after&#39;, &#39;className&#39;);

<span id='Tk-Class-cfg-uses'>    /**
</span>     * @cfg {String[]} uses
     * @member Tk.Class
     * List of optional classes to load together with this class. These aren&#39;t neccessarily loaded before
     * this class is created, but are guaranteed to be available before Tk.onReady listeners are
     * invoked. For example:
     *
     *     Tk.define(&#39;Mother&#39;, {
     *         uses: [&#39;Child&#39;],
     *         giveBirth: function() {
     *             // This code might, or might not work:
     *             // return new Child();
     *
     *             // Instead use Tk.create() to load the class at the spot if not loaded already:
     *             return Tk.create(&#39;Child&#39;);
     *         }
     *     });
     */
    Manager.registerPostprocessor(&#39;uses&#39;, function(name, cls, data) {
        //&lt;debug&gt;
        Tk.classSystemMonitor &amp;&amp; Tk.classSystemMonitor(cls, &#39;Tk.Loader#usesPostprocessor&#39;, arguments); // jshint ignore:line
        //&lt;/debug&gt;
        
        var manifest = Tk.manifest,
            loadOrder = manifest &amp;&amp; manifest.loadOrder,
            classes = manifest &amp;&amp; manifest.classes,
            uses, clazz, item, len, i, indexMap;

        if (loadOrder) {
            clazz = classes[name];
            if (clazz &amp;&amp; !isNaN(i = clazz.idx)) {
                item = loadOrder[i];
                uses = item.uses;
                indexMap = {};
                for (len = uses.length, i = 0; i &lt; len; i++) {
                    indexMap[uses[i]] = true;
                }
                uses = Tk.Boot.getPathsFromIndexes(indexMap, loadOrder, true);
                if (uses.length &gt; 0) {
                    Loader.loadScripts({
                        url: uses,
                        sequential: true
                    });
                }
            }
        }

        if (data.uses) {
            uses = data.uses;
            Loader.addUsedClasses(uses);
        }
    });

    Manager.onCreated(Loader.historyPush);
//&lt;/feature&gt;

    Loader.init();
    
}());

//-----------------------------------------------------------------------------

// Use performance.now when available to keep timestamps consistent.
Tk._endTime = Tk.ticks();

// This hook is to allow tools like DynaTrace to deterministically detect the availability
// of Tk.onReady. Since Loader takes over Tk.onReady this must be done here and not in
// Tk.env.Ready.
if (Tk._beforereadyhandler){
    Tk._beforereadyhandler();
}
</pre>
</body>
</html>
