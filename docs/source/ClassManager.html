<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">// @tag class
<span id='Tk-ClassManager'>/**
</span> * @class Tk.ClassManager
 *
 * Tk.ClassManager manages all classes and handles mapping from string class name to
 * actual class objects throughout the whole framework. It is not generally accessed directly, rather through
 * these convenient shorthands:
 *
 * - {@link Tk#define Tk.define}
 * - {@link Tk#create Tk.create}
 * - {@link Tk#widget Tk.widget}
 * - {@link Tk#getClass Tk.getClass}
 * - {@link Tk#getClassName Tk.getClassName}
 *
 * # Basic syntax:
 *
 *     Tk.define(className, properties);
 *
 * in which `properties` is an object represent a collection of properties that apply to the class. See
 * {@link Tk.ClassManager#create} for more detailed instructions.
 *
 *     Tk.define(&#39;Person&#39;, {
 *          name: &#39;Unknown&#39;,
 *
 *          constructor: function(name) {
 *              if (name) {
 *                  this.name = name;
 *              }
 *          },
 *
 *          eat: function(foodType) {
 *              alert(&quot;I&#39;m eating: &quot; + foodType);
 *
 *              return this;
 *          }
 *     });
 *
 *     var aaron = new Person(&quot;Aaron&quot;);
 *     aaron.eat(&quot;Sandwich&quot;); // alert(&quot;I&#39;m eating: Sandwich&quot;);
 *
 * Tk.Class has a powerful set of extensible {@link Tk.Class#registerPreprocessor pre-processors} which takes care of
 * everything related to class creation, including but not limited to inheritance, mixins, configuration, statics, etc.
 *
 * # Inheritance:
 *
 *     Tk.define(&#39;Developer&#39;, {
 *          extend: &#39;Person&#39;,
 *
 *          constructor: function(name, isGeek) {
 *              this.isGeek = isGeek;
 *
 *              // Apply a method from the parent class&#39; prototype
 *              this.callParent([name]);
 *          },
 *
 *          code: function(language) {
 *              alert(&quot;I&#39;m coding in: &quot; + language);
 *
 *              this.eat(&quot;Bugs&quot;);
 *
 *              return this;
 *          }
 *     });
 *
 *     var jacky = new Developer(&quot;Jacky&quot;, true);
 *     jacky.code(&quot;JavaScript&quot;); // alert(&quot;I&#39;m coding in: JavaScript&quot;);
 *                               // alert(&quot;I&#39;m eating: Bugs&quot;);
 *
 * See {@link Tk.Base#callParent} for more details on calling superclass&#39; methods
 *
 * # Mixins:
 *
 *     Tk.define(&#39;CanPlayGuitar&#39;, {
 *          playGuitar: function() {
 *             alert(&quot;F#...G...D...A&quot;);
 *          }
 *     });
 *
 *     Tk.define(&#39;CanComposeSongs&#39;, {
 *          composeSongs: function() { ... }
 *     });
 *
 *     Tk.define(&#39;CanSing&#39;, {
 *          sing: function() {
 *              alert(&quot;For he&#39;s a jolly good fellow...&quot;)
 *          }
 *     });
 *
 *     Tk.define(&#39;Musician&#39;, {
 *          extend: &#39;Person&#39;,
 *
 *          mixins: {
 *              canPlayGuitar: &#39;CanPlayGuitar&#39;,
 *              canComposeSongs: &#39;CanComposeSongs&#39;,
 *              canSing: &#39;CanSing&#39;
 *          }
 *     })
 *
 *     Tk.define(&#39;CoolPerson&#39;, {
 *          extend: &#39;Person&#39;,
 *
 *          mixins: {
 *              canPlayGuitar: &#39;CanPlayGuitar&#39;,
 *              canSing: &#39;CanSing&#39;
 *          },
 *
 *          sing: function() {
 *              alert(&quot;Ahem....&quot;);
 *
 *              this.mixins.canSing.sing.call(this);
 *
 *              alert(&quot;[Playing guitar at the same time...]&quot;);
 *
 *              this.playGuitar();
 *          }
 *     });
 *
 *     var me = new CoolPerson(&quot;Jacky&quot;);
 *
 *     me.sing(); // alert(&quot;Ahem...&quot;);
 *                // alert(&quot;For he&#39;s a jolly good fellow...&quot;);
 *                // alert(&quot;[Playing guitar at the same time...]&quot;);
 *                // alert(&quot;F#...G...D...A&quot;);
 *
 * Also see {@link Tk.Base#statics} and {@link Tk.Base#self} for more details on accessing
 * static properties within class methods
 *
 * @singleton
 */
Tk.ClassManager = (function(Class, alias, arraySlice, arrayFrom, global) {
// @define Tk.ClassManager
// @require Tk.Inventory
// @require Tk.Class
// @require Tk.Function
// @require Tk.Array

var makeCtor = Tk.Class.makeCtor,
    //&lt;if nonBrowser&gt;
    isNonBrowser = typeof window === &#39;undefined&#39;,
    //&lt;/if&gt;
    nameLookupStack = [],
    namespaceCache = {
        Tk: {
            name: &#39;Tk&#39;,
            value: Tk // specially added for sandbox (Tk === global.Ext6)
        }
        /*
        &#39;Tk.grid&#39;: {
            name: &#39;grid&#39;,
            parent: namespaceCache[&#39;Tk&#39;]
        },
        &#39;Tk.grid.Panel&#39;: {
            name: &#39;Panel&#39;,
            parent: namespaceCache[&#39;Tk.grid&#39;]
        },
        ...

        Also,
        &#39;MyApp&#39;: {
            name: &#39;MyApp&#39;,
            value: MyApp
        }
        */
    },

    Manager = Tk.apply(new Tk.Inventory(), {
<span id='Tk-ClassManager-property-classes'>        /**
</span>         * @property {Object} classes
         * All classes which were defined through the ClassManager. Keys are the
         * name of the classes and the values are references to the classes.
         * @private
         */
        classes: {},

        classState: {
            /*
             * &#39;Tk.foo.Bar&#39;: &lt;state enum&gt;
             *
             *  10 = Tk.define called
             *  20 = Tk.define/override called
             *  30 = Manager.existCache[&lt;name&gt;] == true for define
             *  40 = Manager.existCache[&lt;name&gt;] == true for define/override
             *  50 = Manager.isCreated(&lt;name&gt;) == true for define
             *  60 = Manager.isCreated(&lt;name&gt;) == true for define/override
             *
             */
        },

<span id='Tk-ClassManager-property-existCache'>        /**
</span>         * @private
         */
        existCache: {},

<span id='Tk-ClassManager-property-instantiators'>        /** @private */
</span>        instantiators: [],

<span id='Tk-ClassManager-method-isCreated'>        /**
</span>         * Checks if a class has already been created.
         *
         * @param {String} className
         * @return {Boolean} exist
         */
        isCreated: function(className) {
            //&lt;debug&gt;
            if (typeof className !== &#39;string&#39; || className.length &lt; 1) {
                throw new Error(&quot;[Tk.ClassManager] Invalid classname, must be a string and must not be empty&quot;);
            }
            //&lt;/debug&gt;

            if (Manager.classes[className] || Manager.existCache[className]) {
                return true;
            }

            if (!Manager.lookupName(className, false)) {
                return false;
            }

            Manager.triggerCreated(className);
            return true;
        },

<span id='Tk-ClassManager-property-createdListeners'>        /**
</span>         * @private
         */
        createdListeners: [],

<span id='Tk-ClassManager-property-nameCreatedListeners'>        /**
</span>         * @private
         */
        nameCreatedListeners: {},

<span id='Tk-ClassManager-property-existsListeners'>        /**
</span>         * @private
         */
        existsListeners: [],

<span id='Tk-ClassManager-property-nameExistsListeners'>        /**
</span>         * @private
         */
        nameExistsListeners: {},

<span id='Tk-ClassManager-property-overrideMap'>        /**
</span>         * @private
         */
        overrideMap: {},

<span id='Tk-ClassManager-method-triggerCreated'>        /**
</span>         * @private
         */
        triggerCreated: function (className, state) {
            Manager.existCache[className] = state || 1;
            Manager.classState[className] += 40;
            Manager.notify(className, Manager.createdListeners, Manager.nameCreatedListeners);
        },

<span id='Tk-ClassManager-method-onCreated'>        /**
</span>         * @private
         */
        onCreated: function(fn, scope, className) {
            Manager.addListener(fn, scope, className, Manager.createdListeners, Manager.nameCreatedListeners);
        },

<span id='Tk-ClassManager-method-notify'>        /**
</span>         * @private
         */
        notify: function (className, listeners, nameListeners) {
            var alternateNames = Manager.getAlternatesByName(className),
                names = [className],
                i, ln, j, subLn, listener, name;

            for (i = 0,ln = listeners.length; i &lt; ln; i++) {
                listener = listeners[i];
                listener.fn.call(listener.scope, className);
            }

            while (names) {
                for (i = 0,ln = names.length; i &lt; ln; i++) {
                    name = names[i];
                    listeners = nameListeners[name];

                    if (listeners) {
                        for (j = 0,subLn = listeners.length; j &lt; subLn; j++) {
                            listener = listeners[j];
                            listener.fn.call(listener.scope, name);
                        }
                        delete nameListeners[name];
                    }
                }

                names = alternateNames; // for 2nd pass (if needed)
                alternateNames = null; // no 3rd pass
            }
        },

<span id='Tk-ClassManager-method-addListener'>        /**
</span>         * @private
         */
        addListener: function(fn, scope, className, listeners, nameListeners) {
            if (Tk.isArray(className)) {
                fn = Tk.Function.createBarrier(className.length, fn, scope);
                for (i = 0; i &lt; className.length; i++) {
                    this.addListener(fn, null, className[i], listeners, nameListeners);
                }
                return;
            }
            var i,
                listener = {
                    fn: fn,
                    scope: scope
                };

            if (className) {
                if (this.isCreated(className)) {
                    fn.call(scope, className);
                    return;
                }

                if (!nameListeners[className]) {
                    nameListeners[className] = [];
                }

                nameListeners[className].push(listener);
            }
            else {
                listeners.push(listener);
            }
        },

<span id='Tk-ClassManager-property-S-namespaceCache'>        /**
</span>         * Supports namespace rewriting.
         * @private
         */
        $namespaceCache: namespaceCache,

<span id='Tk-ClassManager-method-addRootNamespaces'>        /**
</span>         * See `{@link Tk#addRootNamespaces Tk.addRootNamespaces}`.
         * @since 6.0.0
         * @private
         */
        addRootNamespaces: function (namespaces) {
            for (var name in namespaces) {
                namespaceCache[name] = {
                    name: name,
                    value: namespaces[name]
                };
            }
        },

<span id='Tk-ClassManager-method-clearNamespaceCache'>        /**
</span>         * Clears the namespace lookup cache. After application launch, this cache can
         * often contain several hundred entries that are unlikely to be needed again.
         * These will be rebuilt as needed, so it is harmless to clear this cache even
         * if its results will be used again.
         * @since 6.0.0
         * @private
         */
        clearNamespaceCache: function () {
            nameLookupStack.length = 0;

            for (var name in namespaceCache) {
                if (!namespaceCache[name].value) {
                    delete namespaceCache[name];
                }
            }
        },

<span id='Tk-ClassManager-method-getNamespaceEntry'>        /**
</span>         * Return the namespace cache entry for the given a class name or namespace (e.g.,
         * &quot;Tk.grid.Panel&quot;).
         *
         * @param {String} namespace The namespace or class name to lookup.
         * @return {Object} The cache entry.
         * @return {String} return.name The leaf name (&quot;Panel&quot; for &quot;Tk.grid.Panel&quot;).
         * @return {Object} return.parent The entry of the parent namespace (i.e., &quot;Tk.grid&quot;).
         * @return {Object} return.value The namespace object. This is only set for
         * top-level namespace entries to support renaming them for sandboxing (&quot;Ext6&quot; vs
         * &quot;Tk&quot;).
         * @since 6.0.0
         * @private
         */
        getNamespaceEntry: function (namespace) {
            if (typeof namespace !== &#39;string&#39;) {
                return namespace;  // assume we&#39;ve been given an entry object
            }

            var entry = namespaceCache[namespace],
                i;

            if (!entry) {
                i = namespace.lastIndexOf(&#39;.&#39;);

                if (i &lt; 0) {
                    entry = {
                        name: namespace
                    };
                } else {
                    entry = {
                        name: namespace.substring(i + 1),
                        parent: Manager.getNamespaceEntry(namespace.substring(0, i))
                    };
                }

                namespaceCache[namespace] = entry;
            }

            return entry;
        },

<span id='Tk-ClassManager-method-lookupName'>        /**
</span>         * Return the value of the given &quot;dot path&quot; name. This supports remapping (for use
         * in sandbox builds) as well as auto-creating of namespaces.
         *
         * @param {String} namespace The name of the namespace or class.
         * @param {Boolean} [autoCreate] Pass `true` to create objects for undefined names.
         * @return {Object} The object that is the namespace or class name.
         * @since 6.0.0
         * @private
         */
        lookupName: function (namespace, autoCreate) {
            var entry = Manager.getNamespaceEntry(namespace),
                scope = Tk.global,
                i = 0,
                e, parent;

            // Put entries on the stack in reverse order: [ &#39;Panel&#39;, &#39;grid&#39;, &#39;Tk&#39; ]
            for (e = entry; e; e = e.parent) {
                // since we process only what we add to the array, and that always
                // starts at index=0, we don&#39;t need to clean up the array (that would
                // just encourage the GC to do something pointless).
                nameLookupStack[i++] = e;
            }

            while (scope &amp;&amp; i-- &gt; 0) {
                // We&#39;ll process entries in top-down order (&#39;Tk&#39;, &#39;grid&#39; then &#39;Panel&#39;).
                e = nameLookupStack[i];
                parent = scope;

                scope = e.value || scope[e.name];

                if (!scope &amp;&amp; autoCreate) {
                    parent[e.name] = scope = {};
                }
            }

            return scope;
        },

<span id='Tk-ClassManager-method-setNamespace'>        /**
</span>         * Creates a namespace and assign the `value` to the created object.
         *
         *     Tk.ClassManager.setNamespace(&#39;MyCompany.pkg.Example&#39;, someObject);
         *
         *     alert(MyCompany.pkg.Example === someObject); // alerts true
         *
         * @param {String} name
         * @param {Object} value
         */
        setNamespace: function (namespace, value) {
            var entry = Manager.getNamespaceEntry(namespace),
                scope = Tk.global;

            if (entry.parent) {
                scope = Manager.lookupName(entry.parent, true);
            }

            scope[entry.name] = value;

            return value;
        },

<span id='Tk-ClassManager-method-set'>        /**
</span>         * Sets a name reference to a class.
         *
         * @param {String} name
         * @param {Object} value
         * @return {Tk.ClassManager} this
         */
        set: function (name, value) {
            var targetName = Manager.getName(value);

            Manager.classes[name] = Manager.setNamespace(name, value);

            if (targetName &amp;&amp; targetName !== name) {
                Manager.addAlternate(targetName, name);
            }

            return Manager;
        },

<span id='Tk-ClassManager-method-get'>        /**
</span>         * Retrieve a class by its name.
         *
         * @param {String} name
         * @return {Tk.Class} class
         */
        get: function(name) {
            return Manager.classes[name] || Manager.lookupName(name, false);
        },

<span id='Tk-ClassManager-method-addNameAliasMappings'>        /**
</span>         * Adds a batch of class name to alias mappings.
         * @param {Object} aliases The set of mappings of the form.
         * className : [values...]
         */
        addNameAliasMappings: function(aliases) {
            Manager.addAlias(aliases);
        },

<span id='Tk-ClassManager-method-addNameAlternateMappings'>        /**
</span>         *
         * @param {Object} alternates The set of mappings of the form
         * className : [values...]
         */
        addNameAlternateMappings: function (alternates) {
            Manager.addAlternate(alternates);
        },

<span id='Tk-ClassManager-method-getByAlias'>        /**
</span>         * Get a reference to the class by its alias.
         *
         * @param {String} alias
         * @return {Tk.Class} class
         */
        getByAlias: function(alias) {
            return Manager.get(Manager.getNameByAlias(alias));
        },

<span id='Tk-ClassManager-method-getByConfig'>        /**
</span>         * Get a component class name from a config object.
         * @param {Object} config The config object.
         * @param {String} [aliasPrefix] A prefix to use when getting
         * a class name by alias.
         * @return {Tk.Class} The class.
         *
         * @private
         */
        getByConfig: function(config, aliasPrefix) {
            var xclass = config.xclass,
                name;

            if (xclass) {
                name = xclass;
            } else {
                name = config.xtype;
                if (name) {
                    aliasPrefix = &#39;widget.&#39;;
                } else {
                    name = config.type;
                }
                name = Manager.getNameByAlias(aliasPrefix + name);
            }
            return Manager.get(name);
        },        

<span id='Tk-ClassManager-method-getName'>        /**
</span>         * Get the name of the class by its reference or its instance. This is
         * usually invoked by the shorthand {@link Tk#getClassName}.
         *
         *     Tk.ClassManager.getName(Tk.Action); // returns &quot;Tk.Action&quot;
         *
         * @param {Tk.Class/Object} object
         * @return {String} className
         */
        getName: function(object) {
            return object &amp;&amp; object.$className || &#39;&#39;;
        },

<span id='Tk-ClassManager-method-getClass'>        /**
</span>         * Get the class of the provided object; returns null if it&#39;s not an instance
         * of any class created with Tk.define. This is usually invoked by the
         * shorthand {@link Tk#getClass}.
         *
         *     var component = new Tk.Component();
         *
         *     Tk.getClass(component); // returns Tk.Component
         *
         * @param {Object} object
         * @return {Tk.Class} class
         */
        getClass: function(object) {
            return object &amp;&amp; object.self || null;
        },

<span id='Tk-ClassManager-method-create'>        /**
</span>         * Defines a class.
         * @deprecated Use {@link Tk#define} instead, as that also supports creating overrides.
         * @private
         */
        create: function(className, data, createdFn) {
            //&lt;debug&gt;
            if (className != null &amp;&amp; typeof className !== &#39;string&#39;) {
                throw new Error(&quot;[Tk.define] Invalid class name &#39;&quot; + className + &quot;&#39; specified, must be a non-empty string&quot;);
            }
            //&lt;/debug&gt;

            var ctor = makeCtor(className);
            if (typeof data === &#39;function&#39;) {
                data = data(ctor);
            }

            //&lt;debug&gt;
            if (className) {
                if (Manager.classes[className]) {
                    Tk.log.warn(&quot;[Tk.define] Duplicate class name &#39;&quot; + className + &quot;&#39; specified, must be a non-empty string&quot;);
                }
                ctor.name = className;
            }
            //&lt;/debug&gt;

            data.$className = className;

            return new Class(ctor, data, function() {
                var postprocessorStack = data.postprocessors || Manager.defaultPostprocessors,
                    registeredPostprocessors = Manager.postprocessors,
                    postprocessors = [],
                    postprocessor, i, ln, j, subLn, postprocessorProperties, postprocessorProperty;

                delete data.postprocessors;

                for (i = 0,ln = postprocessorStack.length; i &lt; ln; i++) {
                    postprocessor = postprocessorStack[i];

                    if (typeof postprocessor === &#39;string&#39;) {
                        postprocessor = registeredPostprocessors[postprocessor];
                        postprocessorProperties = postprocessor.properties;

                        if (postprocessorProperties === true) {
                            postprocessors.push(postprocessor.fn);
                        }
                        else if (postprocessorProperties) {
                            for (j = 0,subLn = postprocessorProperties.length; j &lt; subLn; j++) {
                                postprocessorProperty = postprocessorProperties[j];

                                if (data.hasOwnProperty(postprocessorProperty)) {
                                    postprocessors.push(postprocessor.fn);
                                    break;
                                }
                            }
                        }
                    }
                    else {
                        postprocessors.push(postprocessor);
                    }
                }

                data.postprocessors = postprocessors;
                data.createdFn = createdFn;
                Manager.processCreate(className, this, data);
            });
        },

        processCreate: function(className, cls, clsData){
            var me = this,
                postprocessor = clsData.postprocessors.shift(),
                createdFn = clsData.createdFn;

            if (!postprocessor) {
                //&lt;debug&gt;
                Tk.classSystemMonitor &amp;&amp; Tk.classSystemMonitor(className, &#39;Tk.ClassManager#classCreated&#39;, arguments);
                //&lt;/debug&gt;

                if (className) {
                    me.set(className, cls);
                }

                delete cls._classHooks;

                if (createdFn) {
                    createdFn.call(cls, cls);
                }

                if (className) {
                    me.triggerCreated(className);
                }
                return;
            }

            if (postprocessor.call(me, className, cls, clsData, me.processCreate) !== false) {
                me.processCreate(className, cls, clsData);
            }
        },

        createOverride: function (className, data, createdFn) {
            var me = this,
                overriddenClassName = data.override,
                requires = data.requires,
                uses = data.uses,
                mixins = data.mixins,
                mixinsIsArray,
                compat = 1, // default if &#39;compatibility&#39; is not specified
                depedenciesLoaded,
                classReady = function () {
                    var cls, dependencies, i, key, temp;

                    if (!depedenciesLoaded) {
                        dependencies = requires ? requires.slice(0) : [];

                        if (mixins) {
                            if (!(mixinsIsArray = mixins instanceof Array)) {
                                for (key in mixins) {
                                    if (Tk.isString(cls = mixins[key])) {
                                        dependencies.push(cls);
                                    }
                                }
                            } else {
                                for (i = 0, temp = mixins.length; i &lt; temp; ++i) {
                                    if (Tk.isString(cls = mixins[i])) {
                                        dependencies.push(cls);
                                    }
                                }
                            }
                        }

                        depedenciesLoaded = true;
                        if (dependencies.length) {
                            // Since the override is going to be used (its target class is
                            // now created), we need to fetch the required classes for the
                            // override and call us back once they are loaded:
                            Tk.require(dependencies, classReady);
                            return;
                        }
                        // else we have no dependencies, so proceed
                    }

                    // transform mixin class names into class references, This
                    // loop can handle both the array and object forms of
                    // mixin definitions
                    if (mixinsIsArray) {
                        for (i = 0, temp = mixins.length; i &lt; temp; ++i) {
                            if (Tk.isString(cls = mixins[i])) {
                                mixins[i] = Tk.ClassManager.get(cls);
                            }
                        }
                    } else if (mixins) {
                        for (key in mixins) {
                            if (Tk.isString(cls = mixins[key])) {
                                mixins[key] = Tk.ClassManager.get(cls);
                            }
                        }
                    }

                    // The target class and the required classes for this override are
                    // ready, so we can apply the override now:
                    cls = me.get(overriddenClassName);

                    // We don&#39;t want to apply these:
                    delete data.override;
                    delete data.compatibility;
                    delete data.requires;
                    delete data.uses;

                    Tk.override(cls, data);


                    // This pushes the overriding file itself into Ext.Loader.history
                    // Hence if the target class never exists, the overriding file will
                    // never be included in the build.
                    Ext.Loader.history.push(className);

                    if (uses) {
                        // This &quot;hides&quot; from the Cmd auto-dependency scanner since
                        // the reference is circular (Loader requires us).
                        Ext[&#39;Loader&#39;].addUsedClasses(uses); // get these classes too!
                    }

                    if (createdFn) {
                        createdFn.call(cls, cls); // last but not least!
                    }
                };

            Manager.overrideMap[className] = true;

            // If specified, parse strings as versions, but otherwise treat as a
            // boolean (maybe &quot;compatibility: Tk.isIE8&quot; or something).
            //
            if (&#39;compatibility&#39; in data &amp;&amp; Tk.isString(compat = data.compatibility)) {
                compat = Tk.checkVersion(compat);
            }

            if (compat) {
                // Override the target class right after it&#39;s created
                me.onCreated(classReady, me, overriddenClassName);
            }

            me.triggerCreated(className, 2);
            return me;
        },

<span id='Tk-ClassManager-method-instantiateByAlias'>        /**
</span>         * Instantiate a class by its alias. This is usually invoked by the
         * shorthand {@link Tk#createByAlias}.
         *
         * If {@link Tk.Loader} is {@link Tk.Loader#setConfig enabled} and the class
         * has not been defined yet, it will attempt to load the class via synchronous
         * loading.
         *
         *     var window = Tk.createByAlias(&#39;widget.window&#39;, { width: 600, height: 800 });
         *
         * @param {String} alias
         * @param {Object...} args Additional arguments after the alias will be passed to the
         * class constructor.
         * @return {Object} instance
         */
        instantiateByAlias: function() {
            var alias = arguments[0],
                args = arraySlice.call(arguments),
                className = this.getNameByAlias(alias);

            //&lt;debug&gt;
            if (!className) {
                throw new Error(&quot;[Tk.createByAlias] Unrecognized alias: &quot; + alias);
            }
            //&lt;/debug&gt;

            args[0] = className;

            return Tk.create.apply(Tk, args);
        },

        //&lt;deprecated since=5.0&gt;
<span id='Tk-ClassManager-method-instantiate'>        /**
</span>         * Instantiate a class by either full name, alias or alternate name
         * @param {String} name
         * @param {Mixed} args Additional arguments after the name will be passed to the class&#39; constructor.
         * @return {Object} instance
         * @deprecated 5.0 Use Tk.create() instead.
         */
        instantiate: function() {
            //&lt;debug&gt;
            Tk.log.warn(&#39;Tk.ClassManager.instantiate() is deprecated.  Use Tk.create() instead.&#39;);
            //&lt;/debug&gt;
            return Tk.create.apply(Tk, arguments);
        },
        //&lt;/deprecated&gt;

<span id='Tk-ClassManager-method-dynInstantiate'>        /**
</span>         * @private
         * @param name
         * @param args
         */
        dynInstantiate: function(name, args) {
            args = arrayFrom(args, true);
            args.unshift(name);

            return Tk.create.apply(Tk, args);
        },

<span id='Tk-ClassManager-method-getInstantiator'>        /**
</span>         * @private
         * @param length
         */
        getInstantiator: function(length) {
            var instantiators = this.instantiators,
                instantiator,
                i,
                args;

            instantiator = instantiators[length];

            if (!instantiator) {
                i = length;
                args = [];

                for (i = 0; i &lt; length; i++) {
                    args.push(&#39;a[&#39; + i + &#39;]&#39;);
                }

                instantiator = instantiators[length] = new Function(&#39;c&#39;, &#39;a&#39;, &#39;return new c(&#39; + args.join(&#39;,&#39;) + &#39;)&#39;);
                //&lt;debug&gt;
                instantiator.name = &quot;Tk.create&quot; + length;
                //&lt;/debug&gt;
            }

            return instantiator;
        },

<span id='Tk-ClassManager-property-postprocessors'>        /**
</span>         * @private
         */
        postprocessors: {},

<span id='Tk-ClassManager-property-defaultPostprocessors'>        /**
</span>         * @private
         */
        defaultPostprocessors: [],

<span id='Tk-ClassManager-method-registerPostprocessor'>        /**
</span>         * Register a post-processor function.
         *
         * @private
         * @param {String} name
         * @param {Function} postprocessor
         */
        registerPostprocessor: function(name, fn, properties, position, relativeTo) {
            if (!position) {
                position = &#39;last&#39;;
            }

            if (!properties) {
                properties = [name];
            }

            this.postprocessors[name] = {
                name: name,
                properties: properties || false,
                fn: fn
            };

            this.setDefaultPostprocessorPosition(name, position, relativeTo);

            return this;
        },

<span id='Tk-ClassManager-method-setDefaultPostprocessors'>        /**
</span>         * Set the default post processors array stack which are applied to every class.
         *
         * @private
         * @param {String/Array} postprocessors The name of a registered post processor or an array of registered names.
         * @return {Tk.ClassManager} this
         */
        setDefaultPostprocessors: function(postprocessors) {
            this.defaultPostprocessors = arrayFrom(postprocessors);

            return this;
        },

<span id='Tk-ClassManager-method-setDefaultPostprocessorPosition'>        /**
</span>         * Insert this post-processor at a specific position in the stack, optionally relative to
         * any existing post-processor
         *
         * @private
         * @param {String} name The post-processor name. Note that it needs to be registered with
         * {@link Tk.ClassManager#registerPostprocessor} before this
         * @param {String} offset The insertion position. Four possible values are:
         * &#39;first&#39;, &#39;last&#39;, or: &#39;before&#39;, &#39;after&#39; (relative to the name provided in the third argument)
         * @param {String} relativeName
         * @return {Tk.ClassManager} this
         */
        setDefaultPostprocessorPosition: function(name, offset, relativeName) {
            var defaultPostprocessors = this.defaultPostprocessors,
                index;

            if (typeof offset === &#39;string&#39;) {
                if (offset === &#39;first&#39;) {
                    defaultPostprocessors.unshift(name);

                    return this;
                }
                else if (offset === &#39;last&#39;) {
                    defaultPostprocessors.push(name);

                    return this;
                }

                offset = (offset === &#39;after&#39;) ? 1 : -1;
            }

            index = Tk.Array.indexOf(defaultPostprocessors, relativeName);

            if (index !== -1) {
                Tk.Array.splice(defaultPostprocessors, Math.max(0, index + offset), 0, name);
            }

            return this;
        }
    });

<span id='Tk-Class-cfg-xtype'>    /**
</span>     * @cfg xtype
     * @member Tk.Class
     * @inheritdoc Tk.Component#cfg-xtype
     */

<span id='Tk-Class-cfg-override'>    /**
</span>     * @cfg {String} override
     * @member Tk.Class
     * Overrides members of the specified `target` class.
     * 
     * **NOTE:** the overridden class must have been defined using 
     * {@link Tk#define Tk.define} in order to use the `override` config.
     * 
     * Methods defined on the overriding class will not automatically call the methods of 
     * the same name in the ancestor class chain.  To call the parent&#39;s method of the 
     * same name you must call {@link Tk.Base#callParent callParent}.  To skip the 
     * method of the overridden class and call its parent you will instead call 
     * {@link Tk.Base#callSuper callSuper}.
     *
     * See {@link Tk#define Tk.define} for additional usage examples.
     */
    
    //&lt;feature classSystem.alias&gt;
<span id='Tk-Class-cfg-alias'>    /**
</span>     * @cfg {String/String[]} alias
     * @member Tk.Class
     * List of short aliases for class names. An alias consists of a namespace and a name
     * concatenated by a period as &amp;#60;namespace&amp;#62;.&amp;#60;name&amp;#62;
     *
     *  - **namespace** - The namespace describes what kind of alias this is and must be
     *  all lowercase.
     *  - **name** - The name of the alias which allows the lazy-instantiation via the
     *  alias. The name shouldn&#39;t contain any periods.
     *
     * A list of namespaces and the usages are:
     *
     *  - **feature** - {@link Tk.grid.Panel Grid} features
     *  - **plugin** - Plugins
     *  - **store** - {@link Tk.data.Store}
     *  - **widget** - Components
     *
     * Most useful for defining xtypes for widgets:
     *
     *     Tk.define(&#39;MyApp.CoolPanel&#39;, {
     *         extend: &#39;Tk.panel.Panel&#39;,
     *         alias: [&#39;widget.coolpanel&#39;],
     *         title: &#39;Yeah!&#39;
     *     });
     *
     *     // Using Tk.create
     *     Tk.create(&#39;widget.coolpanel&#39;);
     *
     *     // Using the shorthand for defining widgets by xtype
     *     Tk.widget(&#39;panel&#39;, {
     *         items: [
     *             {xtype: &#39;coolpanel&#39;, html: &#39;Foo&#39;},
     *             {xtype: &#39;coolpanel&#39;, html: &#39;Bar&#39;}
     *         ]
     *     });
     */
    Manager.registerPostprocessor(&#39;alias&#39;, function(name, cls, data) {
        //&lt;debug&gt;
        Tk.classSystemMonitor &amp;&amp; Tk.classSystemMonitor(name, &#39;Tk.ClassManager#aliasPostProcessor&#39;, arguments);
        //&lt;/debug&gt;
        
        var aliases = Tk.Array.from(data.alias),
            i, ln;

        for (i = 0,ln = aliases.length; i &lt; ln; i++) {
            alias = aliases[i];

            this.addAlias(cls, alias);
        }

    }, [&#39;xtype&#39;, &#39;alias&#39;]);
    //&lt;/feature&gt;

    //&lt;feature classSystem.singleton&gt;
<span id='Tk-Class-cfg-singleton'>    /**
</span>     * @cfg {Boolean} singleton
     * @member Tk.Class
     * When set to true, the class will be instantiated as singleton.  For example:
     *
     *     Tk.define(&#39;Logger&#39;, {
     *         singleton: true,
     *         log: function(msg) {
     *             console.log(msg);
     *         }
     *     });
     *
     *     Logger.log(&#39;Hello&#39;);
     */
    Manager.registerPostprocessor(&#39;singleton&#39;, function(name, cls, data, fn) {
        //&lt;debug&gt;
        Tk.classSystemMonitor &amp;&amp; Tk.classSystemMonitor(name, &#39;Tk.ClassManager#singletonPostProcessor&#39;, arguments);
        //&lt;/debug&gt;
        
        if (data.singleton) {
            fn.call(this, name, new cls(), data);
        }
        else {
            return true;
        }
        return false;
    });
    //&lt;/feature&gt;

    //&lt;feature classSystem.alternateClassName&gt;
<span id='Tk-Class-cfg-alternateClassName'>    /**
</span>     * @cfg {String/String[]} alternateClassName
     * @member Tk.Class
     * Defines alternate names for this class.  For example:
     *
     *     Tk.define(&#39;Developer&#39;, {
     *         alternateClassName: [&#39;Coder&#39;, &#39;Hacker&#39;],
     *         code: function(msg) {
     *             alert(&#39;Typing... &#39; + msg);
     *         }
     *     });
     *
     *     var joe = Tk.create(&#39;Developer&#39;);
     *     joe.code(&#39;stackoverflow&#39;);
     *
     *     var rms = Tk.create(&#39;Hacker&#39;);
     *     rms.code(&#39;hack hack&#39;);
     */
    Manager.registerPostprocessor(&#39;alternateClassName&#39;, function(name, cls, data) {
        //&lt;debug&gt;
        Tk.classSystemMonitor &amp;&amp; Tk.classSystemMonitor(name, &#39;Tk.ClassManager#alternateClassNamePostprocessor&#39;, arguments);
        //&lt;/debug&gt;
        
        var alternates = data.alternateClassName,
            i, ln, alternate;

        if (!(alternates instanceof Array)) {
            alternates = [alternates];
        }

        for (i = 0, ln = alternates.length; i &lt; ln; i++) {
            alternate = alternates[i];

            //&lt;debug&gt;
            if (typeof alternate !== &#39;string&#39;) {
                throw new Error(&quot;[Tk.define] Invalid alternate of: &#39;&quot; + alternate + &quot;&#39; for class: &#39;&quot; + name + &quot;&#39;; must be a valid string&quot;);
            }
            //&lt;/debug&gt;

            this.set(alternate, cls);
        }
    });
    //&lt;/feature&gt;

<span id='Tk-ClassManager-cfg-debugHooks'>    /**
</span>     * @cfg {Object} debugHooks
     * A collection of diagnostic methods to decorate the real methods of the class. These
     * methods are applied as an `override` if this class has debug enabled as defined by
     * `Tk.isDebugEnabled`.
     *
     * These will be automatically removed by the Sencha Cmd compiler for production builds.
     *
     * Example usage:
     *
     *      Tk.define(&#39;Foo.bar.Class&#39;, {
     *          foo: function (a, b, c) {
     *              ...
     *          },
     *
     *          bar: function (a, b) {
     *              ...
     *              return 42;
     *          },
     *
     *          debugHooks: {
     *              foo: function (a, b, c) {
     *                  // check arguments...
     *                  return this.callParent(arguments);
     *              }
     *          }
     *      });
     *
     * If you specify a `$enabled` property in the `debugHooks` object that will be used
     * as the default enabled state for the hooks. If the `{@link Tk#manifest}` contains
     * a `debug` object of if `{@link Tk#debugConfig}` is specified, the `$enabled` flag
     * will override its &quot;*&quot; value.
     */
    Manager.registerPostprocessor(&#39;debugHooks&#39;, function(name, Class, data) {
        //&lt;debug&gt;
        Tk.classSystemMonitor &amp;&amp; Tk.classSystemMonitor(Class, &#39;Tk.Class#debugHooks&#39;, arguments);

        if (Tk.isDebugEnabled(Class.$className, data.debugHooks.$enabled)) {
            delete data.debugHooks.$enabled;
            Tk.override(Class, data.debugHooks);
        }
        //&lt;/debug&gt;

        // may already have an instance here in the case of singleton
        var target = Class.isInstance ? Class.self : Class;

        delete target.prototype.debugHooks;
    });

<span id='Tk-ClassManager-cfg-deprecated'>    /**
</span>     * @cfg {Object} deprecated
     * The object given has properties that describe the versions at which the deprecations
     * apply.
     *
     * The purpose of the `deprecated` declaration is to enable development mode to give
     * suitable error messages when deprecated methods or properties are used. Methods can
     * always be injected to provide this feedback, but properties can only be handled on
     * some browsers (those that support `Object.defineProperty`).
     *
     * In some cases, deprecated methods can be restored to their previous behavior or
     * added back if they have been removed.
     *
     * The structure of a `deprecated` declaration is this:
     *
     *      Tk.define(&#39;Foo.bar.Class&#39;, {
     *          ...
     *
     *          deprecated: {
     *              // Optional package name - default is the framework (ext or touch)
     *              name: &#39;foobar&#39;,
     *
     *              &#39;5.0&#39;: {
     *                  methods: {
     *                      // Throws: &#39;&quot;removedMethod&quot; is deprecated.&#39;
     *                      removedMethod: null,
     *
     *                      // Throws: &#39;&quot;oldMethod&quot; is deprecated. Please use &quot;newMethod&quot; instead.&#39;
     *                      oldMethod: &#39;newMethod&#39;,
     *
     *                      // When this block is enabled, this method is applied as an
     *                      // override. Otherwise you get same as &quot;removeMethod&quot;.
     *                      method: function () {
     *                          // Do what v5 &quot;method&quot; did. If &quot;method&quot; exists in newer
     *                          // versions callParent can call it. If 5.1 has &quot;method&quot;
     *                          // then it would be next in line, otherwise 5.2 and last
     *                          // would be the current class.
     *                      },
     *
     *                      moreHelpful: {
     *                          message: &#39;Something helpful to do instead.&#39;,
     *                          fn: function () {
     *                              // The v5 &quot;moreHelpful&quot; method to use when enabled.
     *                          }
     *                      }
     *                  },
     *                  properties: {
     *                      // Throws: &#39;&quot;removedProp&quot; is deprecated.&#39;
     *                      removedProp: null,
     *
     *                      // Throws: &#39;&quot;oldProp&quot; is deprecated. Please use &quot;newProp&quot; instead.&#39;
     *                      oldProp: &#39;newProp&#39;,
     *
     *                      helpful: {
     *                          message: &#39;Something helpful message about what to do.&#39;
     *                      }
     *                      ...
     *                  },
     *                  statics: {
     *                      methods: {
     *                          ...
     *                      },
     *                      properties: {
     *                          ...
     *                      },
     *                  }
     *              },
     *
     *              &#39;5.1&#39;: {
     *                  ...
     *              },
     *
     *              &#39;5.2&#39;: {
     *                  ...
     *              }
     *          }
     *      });
     *
     * The primary content of `deprecated` are the version number keys. These indicate
     * a version number where methods or properties were deprecated. These versions are
     * compared to the version reported by `Tk.getCompatVersion` to determine the action
     * to take for each &quot;block&quot;.
     *
     * When the compatibility version is set to a value less than a version number key,
     * that block is said to be &quot;enabled&quot;. For example, if a method was deprecated in
     * version 5.0 but the desired compatibility level is 4.2 then the block is used to
     * patch methods and (to some degree) restore pre-5.0 compatibility.
     *
     * When multiple active blocks have the same method name, each method is applied as
     * an override in reverse order of version. In the above example, if a method appears
     * in the &quot;5.0&quot;, &quot;5.1&quot; and &quot;5.2&quot; blocks then the &quot;5.2&quot; method is applied as an override
     * first, followed by the &quot;5.1&quot; method and finally the &quot;5.0&quot; method. This means that
     * the `callParent` from the &quot;5.0&quot; method calls the &quot;5.1&quot; method which calls the
     * &quot;5.2&quot; method which can (if applicable) call the current version.
     */
    Manager.registerPostprocessor(&#39;deprecated&#39;, function(name, Class, data) {
        //&lt;debug&gt;
        Tk.classSystemMonitor &amp;&amp; Tk.classSystemMonitor(Class, &#39;Tk.Class#deprecated&#39;, arguments);
        //&lt;/debug&gt;

        // may already have an instance here in the case of singleton
        var target = Class.isInstance ? Class.self : Class;
        target.addDeprecations(data.deprecated);

        delete target.prototype.deprecated;
    });

    Tk.apply(Tk, {
<span id='Tk-method-create'>        /**
</span>         * Instantiate a class by either full name, alias or alternate name.
         *
         * If {@link Tk.Loader} is {@link Tk.Loader#setConfig enabled} and the class has
         * not been defined yet, it will attempt to load the class via synchronous loading.
         *
         * For example, all these three lines return the same result:
         *
         *      // xtype
         *      var window = Tk.create({
         *          xtype: &#39;window&#39;,
         *          width: 600,
         *          height: 800,
         *          ...
         *      });
         *
         *      // alias
         *      var window = Tk.create(&#39;widget.window&#39;, {
         *          width: 600,
         *          height: 800,
         *          ...
         *      });
         *
         *      // alternate name
         *      var window = Tk.create(&#39;Tk.Window&#39;, {
         *          width: 600,
         *          height: 800,
         *          ...
         *      });
         *
         *      // full class name
         *      var window = Tk.create(&#39;Tk.window.Window&#39;, {
         *          width: 600,
         *          height: 800,
         *          ...
         *      });
         *
         *      // single object with xclass property:
         *      var window = Tk.create({
         *          xclass: &#39;Tk.window.Window&#39;, // any valid value for &#39;name&#39; (above)
         *          width: 600,
         *          height: 800,
         *          ...
         *      });
         *
         * @param {String} [name] The class name or alias. Can be specified as `xclass`
         * property if only one object parameter is specified.
         * @param {Object...} [args] Additional arguments after the name will be passed to
         * the class&#39; constructor.
         * @return {Object} instance
         * @member Tk
         * @method create
         */
        create: function () {
            var name = arguments[0],
                nameType = typeof name,
                args = arraySlice.call(arguments, 1),
                cls;

            if (nameType === &#39;function&#39;) {
                cls = name;
            } else {
                if (nameType !== &#39;string&#39; &amp;&amp; args.length === 0) {
                    args = [name];
                    if (!(name = name.xclass)) {
                        name = args[0].xtype;
                        if (name) {
                            name = &#39;widget.&#39; + name;
                        }
                    }
                }

                name = Manager.resolveName(name);
                cls = Manager.get(name);
            }

            // Still not existing at this point, try to load it via synchronous mode as the last resort
            if (!cls) {
                //&lt;debug&gt;
                //&lt;if nonBrowser&gt;
                !isNonBrowser &amp;&amp;
                //&lt;/if&gt;
                Ext.log.warn(&quot;[Ext.Loader] Synchronously loading &#39;&quot; + name + &quot;&#39;; consider adding &quot; +
                     &quot;Ext.require(&#39;&quot; + name + &quot;&#39;) above Ext.onReady&quot;);
                //&lt;/debug&gt;

                Ext.syncRequire(name);

                cls = Manager.get(name);
            }

            return Manager.getInstantiator(args.length)(cls, args);
        },

<span id='Tk-method-widget'>        /**
</span>         * Convenient shorthand to create a widget by its xtype or a config object.
         *
         *      var button = Tk.widget(&#39;button&#39;); // Equivalent to Tk.create(&#39;widget.button&#39;);
         *
         *      var panel = Tk.widget(&#39;panel&#39;, { // Equivalent to Tk.create(&#39;widget.panel&#39;)
         *          title: &#39;Panel&#39;
         *      });
         *
         *      var grid = Tk.widget({
         *          xtype: &#39;grid&#39;,
         *          ...
         *      });
         *
         * If a {@link Tk.Component component} instance is passed, it is simply returned.
         *
         * @member Tk
         * @param {String} [name] The xtype of the widget to create.
         * @param {Object} [config] The configuration object for the widget constructor.
         * @return {Object} The widget instance
         */
        widget: function(name, config) {
            // forms:
            //      1: (xtype)
            //      2: (xtype, config)
            //      3: (config)
            //      4: (xtype, component)
            //      5: (component)
            //      
            var xtype = name,
                alias, className, T;

            if (typeof xtype !== &#39;string&#39;) { // if (form 3 or 5)
                // first arg is config or component
                config = name; // arguments[0]
                xtype = config.xtype;
                className = config.xclass;
            } else {
                config = config || {};
            }

            if (config.isComponent) {
                return config;
            }

            if (!className) {
                alias = &#39;widget.&#39; + xtype;
                className = Manager.getNameByAlias(alias);
            }

            // this is needed to support demand loading of the class
            if (className) {
                T = Manager.get(className);
            }

            if (!T) {
                return Tk.create(className || alias, config);
            }
            return new T(config);
        },

<span id='Tk-method-createByAlias'>        /**
</span>         * @inheritdoc Tk.ClassManager#instantiateByAlias
         * @member Tk
         * @method createByAlias
         */
        createByAlias: alias(Manager, &#39;instantiateByAlias&#39;),

<span id='Tk-method-define'>        /**
</span>         * Defines a class or override. A basic class is defined like this:
         *
         *      Tk.define(&#39;My.awesome.Class&#39;, {
         *          someProperty: &#39;something&#39;,
         *
         *          someMethod: function(s) {
         *              alert(s + this.someProperty);
         *          }
         *
         *          ...
         *      });
         *
         *      var obj = new My.awesome.Class();
         *
         *      obj.someMethod(&#39;Say &#39;); // alerts &#39;Say something&#39;
         *
         * To create an anonymous class, pass `null` for the `className`:
         *
         *      Tk.define(null, {
         *          constructor: function () {
         *              // ...
         *          }
         *      });
         *
         * In some cases, it is helpful to create a nested scope to contain some private
         * properties. The best way to do this is to pass a function instead of an object
         * as the second parameter. This function will be called to produce the class
         * body:
         *
         *      Tk.define(&#39;MyApp.foo.Bar&#39;, function () {
         *          var id = 0;
         *
         *          return {
         *              nextId: function () {
         *                  return ++id;
         *              }
         *          };
         *      });
         * 
         * _Note_ that when using override, the above syntax will not override successfully, because
         * the passed function would need to be executed first to determine whether or not the result 
         * is an override or defining a new object. As such, an alternative syntax that immediately 
         * invokes the function can be used:
         * 
         *      Tk.define(&#39;MyApp.override.BaseOverride&#39;, function () {
         *          var counter = 0;
         *
         *          return {
         *              override: &#39;Tk.Component&#39;,
         *              logId: function () {
         *                  console.log(++counter, this.id);
         *              }
         *          };
         *      }());
         * 
         *
         * When using this form of `Tk.define`, the function is passed a reference to its
         * class. This can be used as an efficient way to access any static properties you
         * may have:
         *
         *      Tk.define(&#39;MyApp.foo.Bar&#39;, function (Bar) {
         *          return {
         *              statics: {
         *                  staticMethod: function () {
         *                      // ...
         *                  }
         *              },
         *
         *              method: function () {
         *                  return Bar.staticMethod();
         *              }
         *          };
         *      });
         *
         * To define an override, include the `override` property. The content of an
         * override is aggregated with the specified class in order to extend or modify
         * that class. This can be as simple as setting default property values or it can
         * extend and/or replace methods. This can also extend the statics of the class.
         *
         * One use for an override is to break a large class into manageable pieces.
         *
         *      // File: /src/app/Panel.js
         *
         *      Tk.define(&#39;My.app.Panel&#39;, {
         *          extend: &#39;Tk.panel.Panel&#39;,
         *          requires: [
         *              &#39;My.app.PanelPart2&#39;,
         *              &#39;My.app.PanelPart3&#39;
         *          ]
         *
         *          constructor: function (config) {
         *              this.callParent(arguments); // calls Tk.panel.Panel&#39;s constructor
         *              //...
         *          },
         *
         *          statics: {
         *              method: function () {
         *                  return &#39;abc&#39;;
         *              }
         *          }
         *      });
         *
         *      // File: /src/app/PanelPart2.js
         *      Tk.define(&#39;My.app.PanelPart2&#39;, {
         *          override: &#39;My.app.Panel&#39;,
         *
         *          constructor: function (config) {
         *              this.callParent(arguments); // calls My.app.Panel&#39;s constructor
         *              //...
         *          }
         *      });
         *
         * Another use of overrides is to provide optional parts of classes that can be
         * independently required. In this case, the class may even be unaware of the
         * override altogether.
         *
         *      Tk.define(&#39;My.ux.CoolTip&#39;, {
         *          override: &#39;Tk.tip.ToolTip&#39;,
         *
         *          constructor: function (config) {
         *              this.callParent(arguments); // calls Tk.tip.ToolTip&#39;s constructor
         *              //...
         *          }
         *      });
         *
         * The above override can now be required as normal.
         *
         *      Tk.define(&#39;My.app.App&#39;, {
         *          requires: [
         *              &#39;My.ux.CoolTip&#39;
         *          ]
         *      });
         *
         * Overrides can also contain statics, inheritableStatics, or privates:
         *
         *      Tk.define(&#39;My.app.BarMod&#39;, {
         *          override: &#39;Tk.foo.Bar&#39;,
         *
         *          statics: {
         *              method: function (x) {
         *                  return this.callParent([x * 2]); // call Tk.foo.Bar.method
         *              }
         *          }
         *      });
         * 
         * Starting in version 4.2.2, overrides can declare their `compatibility` based
         * on the framework version or on versions of other packages. For details on the
         * syntax and options for these checks, see `Tk.checkVersion`.
         * 
         * The simplest use case is to test framework version for compatibility:
         * 
         *      Tk.define(&#39;App.overrides.grid.Panel&#39;, {
         *          override: &#39;Tk.grid.Panel&#39;,
         *
         *          compatibility: &#39;4.2.2&#39;, // only if framework version is 4.2.2
         *
         *          //...
         *      });
         * 
         * An array is treated as an OR, so if any specs match, the override is
         * compatible.
         * 
         *      Tk.define(&#39;App.overrides.some.Thing&#39;, {
         *          override: &#39;Foo.some.Thing&#39;,
         *
         *          compatibility: [
         *              &#39;4.2.2&#39;,
         *              &#39;foo@1.0.1-1.0.2&#39;
         *          ],
         *
         *          //...
         *      });
         * 
         * To require that all specifications match, an object can be provided:
         * 
         *      Tk.define(&#39;App.overrides.some.Thing&#39;, {
         *          override: &#39;Foo.some.Thing&#39;,
         *
         *          compatibility: {
         *              and: [
         *                  &#39;4.2.2&#39;,
         *                  &#39;foo@1.0.1-1.0.2&#39;
         *              ]
         *          },
         *
         *          //...
         *      });
         * 
         * Because the object form is just a recursive check, these can be nested:
         * 
         *      Tk.define(&#39;App.overrides.some.Thing&#39;, {
         *          override: &#39;Foo.some.Thing&#39;,
         *
         *          compatibility: {
         *              and: [
         *                  &#39;4.2.2&#39;,  // exactly version 4.2.2 of the framework *AND*
         *                  {
         *                      // either (or both) of these package specs:
         *                      or: [
         *                          &#39;foo@1.0.1-1.0.2&#39;,
         *                          &#39;bar@3.0+&#39;
         *                      ]
         *                  }
         *              ]
         *          },
         *
         *          //...
         *      });
         *
         * IMPORTANT: An override is only included in a build if the class it overrides is
         * required. Otherwise, the override, like the target class, is not included. In
         * Sencha Cmd v4, the `compatibility` declaration can likewise be used to remove
         * incompatible overrides from a build.
         *
         * @param {String} className The class name to create in string dot-namespaced format, for example:
         * &#39;My.very.awesome.Class&#39;, &#39;FeedViewer.plugin.CoolPager&#39;
         * It is highly recommended to follow this simple convention:
         *  - The root and the class name are &#39;CamelCased&#39;
         *  - Everything else is lower-cased
         * Pass `null` to create an anonymous class.
         * @param {Object} data The key - value pairs of properties to apply to this class. Property names can be of any valid
         * strings, except those in the reserved listed below:
         *  
         *  - {@link Tk.Class#cfg-alias alias}
         *  - {@link Tk.Class#cfg-alternateClassName alternateClassName}
         *  - {@link Tk.Class#cfg-cachedConfig cachedConfig}
         *  - {@link Tk.Class#cfg-config config}
         *  - {@link Tk.Class#cfg-extend extend}
         *  - {@link Tk.Class#cfg-inheritableStatics inheritableStatics}
         *  - {@link Tk.Class#cfg-mixins mixins}
         *  - {@link Tk.Class#cfg-override override}
         *  - {@link Tk.Class#cfg-platformConfig platformConfig}
         *  - {@link Tk.Class#cfg-privates privates}
         *  - {@link Tk.Class#cfg-requires requires}
         *  - `self`
         *  - {@link Tk.Class#cfg-singleton singleton}
         *  - {@link Tk.Class#cfg-statics statics}
         *  - {@link Tk.Class#cfg-uses uses}
         *  - {@link Tk.Class#cfg-xtype xtype} (for {@link Tk.Component Components} only)
         *
         * @param {Function} [createdFn] Callback to execute after the class is created, the execution scope of which
         * (`this`) will be the newly created class itself.
         * @return {Tk.Base}
         * @member Tk
         */
        define: function (className, data, createdFn) {
            //&lt;debug&gt;
            Tk.classSystemMonitor &amp;&amp; Tk.classSystemMonitor(className, &#39;ClassManager#define&#39;, arguments);
            //&lt;/debug&gt;
            
            if (data.override) {
                Manager.classState[className] = 20;
                return Manager.createOverride.apply(Manager, arguments);
            }

            Manager.classState[className] = 10;
            return Manager.create.apply(Manager, arguments);
        },

<span id='Tk-ClassManager-method-undefine'>        /**
</span>         * Undefines a class defined using the #define method. Typically used
         * for unit testing where setting up and tearing down a class multiple
         * times is required.  For example:
         * 
         *     // define a class
         *     Tk.define(&#39;Foo&#39;, {
         *        ...
         *     });
         *     
         *     // run test
         *     
         *     // undefine the class
         *     Tk.undefine(&#39;Foo&#39;);
         * @param {String} className The class name to undefine in string dot-namespaced format.
         * @private
         */
        undefine: function(className) {
            //&lt;debug&gt;
            Tk.classSystemMonitor &amp;&amp; Tk.classSystemMonitor(className, &#39;Tk.ClassManager#undefine&#39;, arguments);
            //&lt;/debug&gt;
        
            var classes = Manager.classes;

            delete classes[className];
            delete Manager.existCache[className];
            delete Manager.classState[className];

            Manager.removeName(className);

            var entry = Manager.getNamespaceEntry(className),
                scope = entry.parent ? Manager.lookupName(entry.parent, false) : Tk.global;

            if (scope) {
                // Old IE blows up on attempt to delete window property
                try {
                    delete scope[entry.name];
                }
                catch (e) {
                    scope[entry.name] = undefined;
                }
            }
        },

<span id='Tk-method-getClassName'>        /**
</span>         * @inheritdoc Tk.ClassManager#getName
         * @member Tk
         * @method getClassName
         */
        getClassName: alias(Manager, &#39;getName&#39;),

<span id='Tk-ClassManager-method-getDisplayName'>        /**
</span>         * Returns the displayName property or className or object. When all else fails, returns &quot;Anonymous&quot;.
         * @param {Object} object
         * @return {String}
         */
        getDisplayName: function(object) {
            if (object) {
                if (object.displayName) {
                    return object.displayName;
                }

                if (object.$name &amp;&amp; object.$class) {
                    return Tk.getClassName(object.$class) + &#39;#&#39; + object.$name;
                }

                if (object.$className) {
                    return object.$className;
                }
            }

            return &#39;Anonymous&#39;;
        },

<span id='Tk-method-getClass'>        /**
</span>         * @inheritdoc Tk.ClassManager#getClass
         * @member Tk
         * @method getClass
         */
        getClass: alias(Manager, &#39;getClass&#39;),

<span id='Tk-method-namespace'>        /**
</span>         * Creates namespaces to be used for scoping variables and classes so that they are not global.
         * Specifying the last node of a namespace implicitly creates all other nodes. Usage:
         *
         *     Tk.namespace(&#39;Company&#39;, &#39;Company.data&#39;);
         *
         *     // equivalent and preferable to the above syntax
         *     Tk.ns(&#39;Company.data&#39;);
         *
         *     Company.Widget = function() { ... };
         *
         *     Company.data.CustomStore = function(config) { ... };
         *
         * @param {String...} namespaces
         * @return {Object} The (last) namespace object created.
         * @member Tk
         * @method namespace
         */
        namespace: function () {
            var root = global,
                i;

            for (i = arguments.length; i-- &gt; 0; ) {
                root = Manager.lookupName(arguments[i], true);
            }

            return root;
        }
    });

<span id='Tk-method-addRootNamespaces'>    /**
</span>     * This function registers top-level (root) namespaces. This is needed for &quot;sandbox&quot;
     * builds.
     *
     *      Tk.addRootNamespaces({
     *          MyApp: MyApp,
     *          Common: Common
     *      });
     *
     * In the above example, `MyApp` and `Common` are top-level namespaces that happen
     * to also be included in the sandbox closure. Something like this:
     *
     *      (function(Tk) {
     *
     *      Tk.sandboxName = &#39;Ext6&#39;;
     *      Tk.isSandboxed = true;
     *      Tk.buildSettings = { baseCSSPrefix: &quot;x6-&quot;, scopeResetCSS: true };
     *
     *      var MyApp = MyApp || {};
     *      Tk.addRootNamespaces({ MyApp: MyApp );
     *
     *      ... normal app.js goes here ...
     *
     *      })(this.Ext6 || (this.Ext6 = {}));
     *
     * The sandbox wrapper around the normally built `app.js` content has to take care
     * of introducing top-level namespaces as well as call this method.
     *
     * @param {Object} namespaces
     * @method addRootNamespaces
     * @member Tk
     * @since 6.0.0
     * @private
     */
    Tk.addRootNamespaces = Manager.addRootNamespaces;

<span id='Tk-method-createWidget'>    /**
</span>     * Old name for {@link Tk#widget}.
     * @deprecated Use {@link Tk#widget} instead.
     * @method createWidget
     * @member Tk
     * @private
     */
    Tk.createWidget = Tk.widget;

<span id='Tk-method-ns'>    /**
</span>     * Convenient alias for {@link Tk#namespace Tk.namespace}.
     * @inheritdoc Tk#namespace
     * @member Tk
     * @method ns
     */
    Tk.ns = Tk.namespace;

    Class.registerPreprocessor(&#39;className&#39;, function(cls, data) {
        if (&#39;$className&#39; in data) {
            cls.$className = data.$className;
            //&lt;debug&gt;
            cls.displayName = cls.$className;
            //&lt;/debug&gt;
        }
        
        //&lt;debug&gt;
        Tk.classSystemMonitor &amp;&amp; Tk.classSystemMonitor(cls, &#39;Tk.ClassManager#classNamePreprocessor&#39;, arguments);
        //&lt;/debug&gt;
    }, true, &#39;first&#39;);

    Class.registerPreprocessor(&#39;alias&#39;, function(cls, data) {
        //&lt;debug&gt;
        Tk.classSystemMonitor &amp;&amp; Tk.classSystemMonitor(cls, &#39;Tk.ClassManager#aliasPreprocessor&#39;, arguments);
        //&lt;/debug&gt;
        
        var prototype = cls.prototype,
            xtypes = arrayFrom(data.xtype),
            aliases = arrayFrom(data.alias),
            widgetPrefix = &#39;widget.&#39;,
            widgetPrefixLength = widgetPrefix.length,
            xtypesChain = Array.prototype.slice.call(prototype.xtypesChain || []),
            xtypesMap = Tk.merge({}, prototype.xtypesMap || {}),
            i, ln, alias, xtype;

        for (i = 0,ln = aliases.length; i &lt; ln; i++) {
            alias = aliases[i];

            //&lt;debug&gt;
            if (typeof alias !== &#39;string&#39; || alias.length &lt; 1) {
                throw new Error(&quot;[Tk.define] Invalid alias of: &#39;&quot; + alias + &quot;&#39; for class: &#39;&quot; + name + &quot;&#39;; must be a valid string&quot;);
            }
            //&lt;/debug&gt;

            if (alias.substring(0, widgetPrefixLength) === widgetPrefix) {
                xtype = alias.substring(widgetPrefixLength);
                Tk.Array.include(xtypes, xtype);
            }
        }

        cls.xtype = data.xtype = xtypes[0];
        data.xtypes = xtypes;

        for (i = 0,ln = xtypes.length; i &lt; ln; i++) {
            xtype = xtypes[i];

            if (!xtypesMap[xtype]) {
                xtypesMap[xtype] = true;
                xtypesChain.push(xtype);
            }
        }

        data.xtypesChain = xtypesChain;
        data.xtypesMap = xtypesMap;

        Tk.Function.interceptAfter(data, &#39;onClassCreated&#39;, function() {
            //&lt;debug&gt;
            Tk.classSystemMonitor &amp;&amp; Tk.classSystemMonitor(cls, &#39;Tk.ClassManager#aliasPreprocessor#afterClassCreated&#39;, arguments);
            //&lt;/debug&gt;
        
            var mixins = prototype.mixins,
                key, mixin;

            for (key in mixins) {
                if (mixins.hasOwnProperty(key)) {
                    mixin = mixins[key];

                    xtypes = mixin.xtypes;

                    if (xtypes) {
                        for (i = 0,ln = xtypes.length; i &lt; ln; i++) {
                            xtype = xtypes[i];

                            if (!xtypesMap[xtype]) {
                                xtypesMap[xtype] = true;
                                xtypesChain.push(xtype);
                            }
                        }
                    }
                }
            }
        });

        for (i = 0,ln = xtypes.length; i &lt; ln; i++) {
            xtype = xtypes[i];

            //&lt;debug&gt;
            if (typeof xtype !== &#39;string&#39; || xtype.length &lt; 1) {
                throw new Error(&quot;[Tk.define] Invalid xtype of: &#39;&quot; + xtype + &quot;&#39; for class: &#39;&quot; + name + &quot;&#39;; must be a valid non-empty string&quot;);
            }
            //&lt;/debug&gt;

            Tk.Array.include(aliases, widgetPrefix + xtype);
        }

        data.alias = aliases;

    }, [&#39;xtype&#39;, &#39;alias&#39;]);

    // load the cmd-5 style app manifest metadata now, if available...
    if (Tk.manifest) {
        var manifest = Tk.manifest,
            classes = manifest.classes,
            paths = manifest.paths,
            aliases = {},
            alternates = {},
            className, obj, name, path, baseUrl;

        if (paths) {
            // if the manifest paths were calculated as relative to the
            // bootstrap file, then we need to prepend Boot.baseUrl to the
            // paths before processing
            if (manifest.bootRelative) {
                baseUrl = Tk.Boot.baseUrl;
                for (path in paths) {
                    if (paths.hasOwnProperty(path)) {
                        paths[path] = baseUrl + paths[path];
                    }
                }
            }
            Manager.setPath(paths);
        }

        if (classes) {
            for (className in classes) {
                alternates[className] = [];
                aliases[className] = [];
                obj = classes[className];
                if (obj.alias) {
                    aliases[className] = obj.alias;
                }
                if (obj.alternates) {
                    alternates[className] = obj.alternates;
                }
            }
        }

        Manager.addAlias(aliases);
        Manager.addAlternate(alternates);
    }

    return Manager;
}(Tk.Class, Tk.Function.alias, Array.prototype.slice, Tk.Array.from, Tk.global));
</pre>
</body>
</html>
