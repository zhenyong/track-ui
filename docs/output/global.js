Ext.data.JsonP.global({"tagname":"class","name":"global","alternateClassNames":[],"members":[{"name":"","tagname":"property","owner":"global","id":"property-","meta":{"protected":true}}],"aliases":{},"files":[{"filename":"","href":""}],"component":false,"superclasses":[],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><div class='doc-contents'><p>Global variables and functions.</p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-property'>Properties</h3><div class='subsection'><div id='property-' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='global'>global</span><br/><a href='source/Mixin.html#global-property-' target='_blank' class='view-source'>view source</a></div><a href='#!/api/global-property-' class='name expandable'></a> : Object<span class=\"signature\"><span class='protected' >protected</span></span></div><div class='description'><div class='short'>This class is a base class for mixins. ...</div><div class='long'><p>This class is a base class for mixins. These are classes that extend this class and are\ndesigned to be used as a <code>mixin</code> by user code.</p>\n\n<p>It provides mixins with the ability to \"hook\" class methods of the classes in to which\nthey are mixed. For example, consider the <code>destroy</code> method pattern. If a mixin class\nhad cleanup requirements, it would need to be called as part of <code>destroy</code>.</p>\n\n<p>Starting with a basic class we might have:</p>\n\n<pre><code> <a href=\"#!/api/Tk-method-define\" rel=\"Tk-method-define\" class=\"docClass\">Tk.define</a>('Foo.bar.Base', {\n     destroy: function () {\n         console.log('B');\n         // cleanup\n     }\n });\n</code></pre>\n\n<p>A derived class would look like this:</p>\n\n<pre><code> <a href=\"#!/api/Tk-method-define\" rel=\"Tk-method-define\" class=\"docClass\">Tk.define</a>('Foo.bar.Derived', {\n     extend: 'Foo.bar.Base',\n\n     destroy: function () {\n         console.log('D');\n         // more cleanup\n\n         this.callParent(); // let Foo.bar.Base cleanup as well\n     }\n });\n</code></pre>\n\n<p>To see how using this class help, start with a \"normal\" mixin class that also needs to\ncleanup its resources. These mixins must be called explicitly by the classes that use\nthem. For example:</p>\n\n<pre><code> <a href=\"#!/api/Tk-method-define\" rel=\"Tk-method-define\" class=\"docClass\">Tk.define</a>('Foo.bar.Util', {\n     destroy: function () {\n         console.log('U');\n     }\n });\n\n <a href=\"#!/api/Tk-method-define\" rel=\"Tk-method-define\" class=\"docClass\">Tk.define</a>('Foo.bar.Derived', {\n     extend: 'Foo.bar.Base',\n\n     mixins: {\n         util: 'Foo.bar.Util'\n     },\n\n     destroy: function () {\n         console.log('D');\n         // more cleanup\n\n         this.mixins.util.destroy.call(this);\n\n         this.callParent(); // let Foo.bar.Base cleanup as well\n     }\n });\n\n var obj = new Foo.bar.Derived();\n\n obj.destroy();\n // logs D then U then B\n</code></pre>\n\n<p>This class is designed to solve the above in simpler and more reliable way.</p>\n\n<h2>mixinConfig</h2>\n\n<p>Using <code>mixinConfig</code> the mixin class can provide \"before\" or \"after\" hooks that do not\ninvolve the derived class implementation. This also means the derived class cannot\nadjust parameters to the hook methods.</p>\n\n<pre><code> <a href=\"#!/api/Tk-method-define\" rel=\"Tk-method-define\" class=\"docClass\">Tk.define</a>('Foo.bar.Util', {\n     extend: 'Tk.Mixin',\n\n     mixinConfig: {\n         after: {\n             destroy: 'destroyUtil'\n         }\n     },\n\n     destroyUtil: function () {\n         console.log('U');\n     }\n });\n\n <a href=\"#!/api/Tk-method-define\" rel=\"Tk-method-define\" class=\"docClass\">Tk.define</a>('Foo.bar.Class', {\n     mixins: {\n         util: 'Foo.bar.Util'\n     },\n\n     destroy: function () {\n         console.log('D');\n     }\n });\n\n var obj = new Foo.bar.Derived();\n\n obj.destroy();\n // logs D then U\n</code></pre>\n\n<p> If the destruction should occur in the other order, you can use <code>before</code>:</p>\n\n<pre><code> <a href=\"#!/api/Tk-method-define\" rel=\"Tk-method-define\" class=\"docClass\">Tk.define</a>('Foo.bar.Util', {\n     extend: 'Tk.Mixin',\n\n     mixinConfig: {\n         before: {\n             destroy: 'destroyUtil'\n         }\n     },\n\n     destroyUtil: function () {\n         console.log('U');\n     }\n });\n\n <a href=\"#!/api/Tk-method-define\" rel=\"Tk-method-define\" class=\"docClass\">Tk.define</a>('Foo.bar.Class', {\n     mixins: {\n         util: 'Foo.bar.Util'\n     },\n\n     destroy: function () {\n         console.log('D');\n     }\n });\n\n var obj = new Foo.bar.Derived();\n\n obj.destroy();\n // logs U then D\n</code></pre>\n\n<h3>Chaining</h3>\n\n<p>One way for a mixin to provide methods that act more like normal inherited methods is\nto use an <code>on</code> declaration. These methods will be injected into the <code>callParent</code> chain\nbetween the derived and superclass. For example:</p>\n\n<pre><code> <a href=\"#!/api/Tk-method-define\" rel=\"Tk-method-define\" class=\"docClass\">Tk.define</a>('Foo.bar.Util', {\n     extend: 'Tk.Mixin',\n\n     mixinConfig: {\n         on: {\n             destroy: function () {\n                 console.log('M');\n             }\n         }\n     }\n });\n\n <a href=\"#!/api/Tk-method-define\" rel=\"Tk-method-define\" class=\"docClass\">Tk.define</a>('Foo.bar.Base', {\n     destroy: function () {\n         console.log('B');\n     }\n });\n\n <a href=\"#!/api/Tk-method-define\" rel=\"Tk-method-define\" class=\"docClass\">Tk.define</a>('Foo.bar.Derived', {\n     extend: 'Foo.bar.Base',\n\n     mixins: {\n         util: 'Foo.bar.Util'\n     },\n\n     destroy: function () {\n         this.callParent();\n         console.log('D');\n     }\n });\n\n var obj = new Foo.bar.Derived();\n\n obj.destroy();\n // logs M then B then D\n</code></pre>\n\n<p>As with <code>before</code> and <code>after</code>, the value of <code>on</code> can be a method name.</p>\n\n<pre><code> <a href=\"#!/api/Tk-method-define\" rel=\"Tk-method-define\" class=\"docClass\">Tk.define</a>('Foo.bar.Util', {\n     extend: 'Tk.Mixin',\n\n     mixinConfig: {\n         on: {\n             destroy: 'onDestroy'\n         }\n     }\n\n     onDestroy: function () {\n         console.log('M');\n     }\n });\n</code></pre>\n\n<p>Because this technique leverages <code>callParent</code>, the derived class controls the time and\nparameters for the call to all of its bases (be they <code>extend</code> or <code>mixin</code> flavor).</p>\n\n<h3>Derivations</h3>\n\n<p>Some mixins need to process class extensions of their target class. To do this you can\ndefine an <code>extended</code> method like so:</p>\n\n<pre><code> <a href=\"#!/api/Tk-method-define\" rel=\"Tk-method-define\" class=\"docClass\">Tk.define</a>('Foo.bar.Util', {\n     extend: 'Tk.Mixin',\n\n     mixinConfig: {\n         extended: function (baseClass, derivedClass, classBody) {\n             // This function is called whenever a new \"derivedClass\" is created\n             // that extends a \"baseClass\" in to which this mixin was mixed.\n         }\n     }\n });\n</code></pre>\n</div></div></div></div></div></div></div>","meta":{}});